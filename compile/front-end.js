#!/usr/bin/env node
             
const fs = require('fs');
const path = require('path');
const stream = require('stream');
const os = require('os');
const vm = require('vm');             const aa=fs.createReadStream,ba=fs.existsSync,r=fs.lstat;var ca=stream;const da=stream.Transform,ea=stream.Writable;const t=(a,b=0,c=!1)=>{if(0===b&&!c)return a;a=a.split("\n",c?b+1:void 0);return c?a[a.length-1]:a.slice(b).join("\n")},fa=(a,b=!1)=>t(a,2+(b?1:0)),u=a=>{({callee:{caller:a}}=a);return a};const ha=os.homedir;const v=/\s+at.*(?:\(|\s)(.*)\)?/,ia=/^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:IGNORED_MODULES)\/.*)?\w+)\.js:\d+:\d+)|native)/,ja=ha(),w=a=>{const {pretty:b=!1,ignoredModules:c=["pirates"]}={},d=c.join("|"),e=new RegExp(ia.source.replace("IGNORED_MODULES",d));return a.replace(/\\/g,"/").split("\n").filter(f=>{f=f.match(v);if(null===f||!f[1])return!0;f=f[1];return f.includes(".app/Contents/Resources/electron.asar")||f.includes(".app/Contents/Resources/default_app.asar")?!1:!e.test(f)}).filter(f=>
f.trim()).map(f=>b?f.replace(v,(h,k)=>h.replace(k,k.replace(ja,"~"))):f).join("\n")};function ka(a,b,c=!1){return function(d){var e=u(arguments),{stack:f}=Error();const h=t(f,2,!0),k=(f=d instanceof Error)?d.message:d;e=[`Error: ${k}`,...null!==e&&a===e||c?[b]:[h,b]].join("\n");e=w(e);return Object.assign(f?d:Error(),{message:k,stack:e})}};function y(a){var {stack:b}=Error();const c=u(arguments);b=fa(b,a);return ka(c,b,a)};const la=(a,b)=>{b.once("error",c=>{a.emit("error",c)});return b};class ma extends ea{constructor(a){const {binary:b=!1,rs:c=null,...d}=a||{},{F:e=y(!0),proxyError:f}=a||{},h=(k,l)=>e(l);super(d);this.a=[];this.A=new Promise((k,l)=>{this.on("finish",()=>{let g;b?g=Buffer.concat(this.a):g=this.a.join("");k(g);this.a=[]});this.once("error",g=>{if(-1==g.stack.indexOf("\n"))h`${g}`;else{const m=w(g.stack);g.stack=m;f&&h`${g}`}l(g)});c&&la(this,c).pipe(this)})}_write(a,b,c){this.a.push(a);c()}get i(){return this.A}}const z=async a=>{({i:a}=new ma({rs:a,F:y(!0)}));return await a};async function A(a){a=aa(a);return await z(a)};const na=vm.Script;const oa=(a,b)=>{const [c,,d]=a.split("\n");a=parseInt(c.replace(/.+?(\d+)$/,(f,h)=>h))-1;const e=d.indexOf("^");({length:b}=b.split("\n").slice(0,a).join("\n"));return b+e+(a?1:0)};const B=a=>{try{new na(a)}catch(b){const c=b.stack;if("Unexpected token <"!=b.message)throw b;return oa(c,a)}return null};function C(a){if("object"!=typeof a)return!1;const b=a.re instanceof RegExp;a=-1!=["string","function"].indexOf(typeof a.replacement);return b&&a}const D=(a,b)=>{if(!(b instanceof Error))throw b;[,,a]=a.stack.split("\n",3);a=b.stack.indexOf(a);if(-1==a)throw b;a=b.stack.substr(0,a-1);const c=a.lastIndexOf("\n");b.stack=a.substr(0,c);throw b;};function E(a,b){function c(){return b.filter(C).reduce((d,{re:e,replacement:f})=>{if(this.b)return d;if("string"==typeof f)return d=d.replace(e,f);{let h;return d.replace(e,(k,...l)=>{h=Error();try{return this.b?k:f.call(this,k,...l)}catch(g){D(h,g)}})}},`${a}`)}c.a=()=>{c.b=!0};return c.call(c)};const pa=a=>new RegExp(`%%_RESTREAM_${a.toUpperCase()}_REPLACEMENT_(\\d+)_%%`,"g"),qa=(a,b)=>`%%_RESTREAM_${a.toUpperCase()}_REPLACEMENT_${b}_%%`,F=(a,b)=>Object.keys(a).reduce((c,d)=>{{var e=a[d];const {getReplacement:f=qa,getRegex:h=pa}=b||{},k=h(d);e={name:d,re:e,regExp:k,getReplacement:f,map:{},lastIndex:0}}return{...c,[d]:e}},{}),G=a=>{var b=[];const c=a.map;return{re:a.regExp,replacement(d,e){d=c[e];delete c[e];return E(d,Array.isArray(b)?b:[b])}}},H=a=>{const b=a.map,c=a.getReplacement,d=a.name;
return{re:a.re,replacement(e){const f=a.lastIndex;b[f]=e;a.lastIndex+=1;return c(d,f)}}};async function ra(a,b){return sa(a,b)}
class I extends da{constructor(a,b){super(b);this.a=(Array.isArray(a)?a:[a]).filter(C);this.b=!1;this.i=b}async replace(a,b){const c=new I(this.a,this.i);b&&Object.assign(c,b);a=await ra(c,a);c.b&&(this.b=!0);b&&Object.keys(b).forEach(d=>{b[d]=c[d]});return a}async reduce(a){return await this.a.reduce(async(b,{re:c,replacement:d})=>{b=await b;if(this.b)return b;if("string"==typeof d)b=b.replace(c,d);else{const e=[];let f;const h=b.replace(c,(k,...l)=>{f=Error();try{if(this.b)return e.length?e.push(Promise.resolve(k)):
k;const g=d.call(this,k,...l);g instanceof Promise&&e.push(g);return g}catch(g){D(f,g)}});if(e.length)try{const k=await Promise.all(e);b=b.replace(c,()=>k.shift())}catch(k){D(f,k)}else b=h}return b},`${a}`)}async _transform(a,b,c){try{const d=await this.reduce(a);this.push(d);c()}catch(d){a=w(d.stack),d.stack=a,c(d)}}}async function sa(a,b){b instanceof ca?b.pipe(a):a.end(b);return await z(a)};const ta=a=>{[,a]=/<\s*(.+?)(?:\s+[\s\S]+)?\s*\/?\s*>/.exec(a)||[];return a},K=a=>{let b=0;const c=[];let d;E(a,[{re:/[{}]/g,replacement(l,g){l="}"==l;const m=!l;if(!b&&l)throw Error("A closing } is found without opening one.");b+=m?1:-1;1==b&&m?d={open:g}:0==b&&l&&(d.close=g,c.push(d),d={})}}]);if(b)throw Error(`Unbalanced props (level ${b}) ${a}`);const e={},f=[],h={};var k=c.reduce((l,{open:g,close:m})=>{l=a.slice(l,g);const [,p,n,q,x]=/(\s*)(\S+)(\s*)=(\s*)$/.exec(l)||[];g=a.slice(g+1,m);if(!n&&
!/\s*\.\.\./.test(g))throw Error("Could not detect prop name");n?e[n]=g:f.push(g);h[n]={before:p,s:q,o:x};g=l||"";g=g.slice(0,g.length-(n||"").length-1);const {m:xa,g:ya}=J(g);Object.assign(e,xa);Object.assign(h,ya);return m+1},0);if(c.length){k=a.slice(k);const {m:l,g}=J(k);Object.assign(e,l);Object.assign(h,g)}else{const {m:l,g}=J(a);Object.assign(e,l);Object.assign(h,g)}return{l:e,j:f,g:h}},J=a=>{const b=[],c={};a.replace(/(\s*)(\S+)(\s*)=(\s*)(["'])([\s\S]+?)\5/g,(d,e,f,h,k,l,g,m)=>{c[f]={before:e,
s:h,o:k};b.push({h:m,name:f,w:`${l}${g}${l}`});return"%".repeat(d.length)}).replace(/(\s*)([^\s%]+)/g,(d,e,f,h)=>{c[f]={before:e};b.push({h,name:f,w:"true"})});return{m:[...b.reduce((d,{h:e,name:f,w:h})=>{d[e]=[f,h];return d},[])].filter(Boolean).reduce((d,[e,f])=>{d[e]=f;return d},{}),g:c}},ua=(a,b=[],c=!1,d={},e="")=>{const f=Object.keys(a);return f.length||b.length?`{${f.reduce((h,k)=>{const l=a[k],g=c||-1!=k.indexOf("-")?`'${k}'`:k,{before:m="",s:p="",o:n=""}=d[k]||{};return[...h,`${m}${g}${p}:${n}${l}`]},
b).join(",")}${e}}`:"{}"},va=(a="")=>{[a]=a;if(!a)throw Error("No tag name is given");return a.toUpperCase()==a},L=(a,b={},c=[],d=[],e=!1,f=null,h={},k="")=>{const l=va(a),g=l?a:`'${a}'`;if(!Object.keys(b).length&&!c.length&&!d.length)return`h(${g})`;const m=l&&"dom"==e?!1:e;l||!d.length||e&&"dom"!=e||f&&f(`JSX: destructuring ${d.join(" ")} is used without quoted props on HTML ${a}.`);a=ua(b,d,m,h,k);b=c.reduce((p,n,q)=>{q=c[q-1];return`${p}${q&&/\S/.test(q)?",":""}${n}`},"");return`h(${g},${a}${b?
`,${b}`:""})`};const M=(a,b=[])=>{let c=0,d;a=E(a,[...b,{re:/[<>]/g,replacement(e,f){if(d)return e;const h="<"==e;c+=h?1:-1;0==c&&!h&&(d=f);return e}}]);if(c)throw Error(1);return{L:a,u:d}},O=a=>{const b=ta(a);let c;const {B:d}=F({B:/=>/g});try{({L:l,u:c}=M(a,[H(d)]))}catch(g){if(1===g)throw Error(`Could not find the matching closing > for ${b}.`);}const e=l.slice(0,c+1);var f=e.replace(/<\s*[^\s/>]+/,"");if(/\/\s*>$/.test(f))return a=f.replace(/\/\s*>$/,""),f="",new N({f:e.replace(d.regExp,"=>"),c:a.replace(d.regExp,
"=>"),content:"",tagName:b});a=f.replace(/>$/,"");f=c+1;c=!1;let h=1,k;E(l,[{re:new RegExp(`[\\s\\S](?:<\\s*${b}(\\s+|>)|/\\s*${b}\\s*>)`,"g"),replacement(g,m,p,n){if(c)return g;m=!m&&g.endsWith(">");const q=!m;if(q){n=n.slice(p);const {u:x}=M(n.replace(/^[\s\S]/," "));n=n.slice(0,x+1);if(/\/\s*>$/.test(n))return g}h+=q?1:-1;0==h&&m&&(c=p,k=c+g.length);return g}}]);if(h)throw Error(`Could not find the matching closing </${b}>.`);f=l.slice(f,c);var l=l.slice(0,k).replace(d.regExp,"=>");return new N({f:l,
c:a.replace(d.regExp,"=>"),content:f.replace(d.regExp,"=>"),tagName:b})};class N{constructor(a){this.f=a.f;this.c=a.c;this.content=a.content;this.tagName=a.tagName}};const P=a=>{let b="",c="";a=a.replace(/^(\n\s*)([\s\S]+)?/,(d,e,f="")=>{b=e;return f}).replace(/([\s\S]+?)?(\n\s*)$/,(d,e="",f="")=>{c=f;return e});return`${b}${a?`\`${a}\``:""}${c}`},za=a=>{const b=[];let c={},d=0,e=0;E(a,[{re:/[<{}]/g,replacement(f,h){if(!(h<e))if(/[{}]/.test(f))d+="{"==f?1:-1,1==d&&void 0==c.from?c.from=h:0==d&&(c.v=h+1,c.G=a.slice(c.from+1,h),b.push(c),c={});else{if(d)return f;f=O(a.slice(h));e=h+f.f.length;c.H=f;c.v=e;c.from=h;b.push(c);c={}}}},{}]);return b.length?wa(a,b):[P(a)]},
wa=(a,b)=>{let c=0;b=b.reduce((d,{from:e,v:f,G:h,H:k})=>{(e=a.slice(c,e))&&d.push(P(e));c=f;h?d.push(h):k&&d.push(k);return d},[]);if(c<a.length){const d=a.slice(c,a.length);d&&b.push(P(d))}return b};const R=(a,b={})=>{var c=b.quoteProps,d=b.warn,e=B(a);if(null===e)return a;var f=a.slice(e);const {c:h="",content:k,tagName:l,f:{length:g}}=O(f);f=Q(k,c,d);const {l:m,j:p,g:n}=K(h.replace(/^ */,""));d=L(l,m,f,p,c,d,n,/\s*$/.exec(h)||[""]);c=a.slice(0,e);a=a.slice(e+g);e=g-d.length;0<e&&(d=`${" ".repeat(e)}${d}`);a=`${c}${d}${a}`;return R(a,b)},Q=(a,b=!1,c=null)=>a?za(a).reduce((d,e)=>{if(e instanceof N){const {c:k="",content:l,tagName:g}=e,{l:m,j:p}=K(k);e=Q(l,b,c);e=L(g,m,e,p,b,c);return[...d,e]}const f=
B(e);if(f){var h=e.slice(f);const {f:{length:k},c:l="",content:g,tagName:m}=O(h),{l:p,j:n}=K(l);h=Q(g,b,c);h=L(m,p,h,n,b,c);const q=e.slice(0,f);e=e.slice(f+k);return[...d,`${q}${h}${e}`]}return[...d,e]},[]):[];const Aa=a=>{const {e:b,C:c,D:d,h:e,I:f,J:h}=F({C:/^ *export\s+default\s+{[\s\S]+?}/mg,e:/^ *export\s+(?:default\s+)?/mg,D:/^ *export\s+{[^}]+}\s+from\s+(['"])(?:.+?)\1/mg,h:/^ *import(\s+([^\s,]+)\s*,?)?(\s*{(?:[^}]+)})?\s+from\s+['"].+['"]/gm,I:/^ *import\s+(?:(.+?)\s*,\s*)?\*\s+as\s+.+?\s+from\s+['"].+['"]/gm,J:/^ *import\s+['"].+['"]/gm},{getReplacement(k,l){return`/*%%_RESTREAM_${k.toUpperCase()}_REPLACEMENT_${l}_%%*/`},getRegex(k){return new RegExp(`/\\*%%_RESTREAM_${k.toUpperCase()}_REPLACEMENT_(\\d+)_%%\\*/`,
"g")}});a=E(a,[H(d),H(c),H(b),H(e),H(f),H(h)]);a=R(a,{});return E(a,[G(d),G(c),G(b),G(e),G(f),G(h)])};function S(a,b){if(b>a-2)throw Error("Function does not accept that many arguments.");}async function T(a,b,c){const d=y(!0);if("function"!==typeof a)throw Error("Function must be passed.");const e=a.length;if(!e)throw Error("Function does not accept any arguments.");return await new Promise((f,h)=>{const k=(g,m)=>g?(g=d(g),h(g)):f(c||m);let l=[k];Array.isArray(b)?(b.forEach((g,m)=>{S(e,m)}),l=[...b,k]):1<Array.from(arguments).length&&(S(e,0),l=[b,k]);a(...l)})};const U=async a=>{try{return await T(r,a)}catch(b){return null}};const V=path.dirname,W=path.join,X=path.relative,Ba=path.resolve;const Ca=async a=>{var b=await U(a);let c=a,d=!1;if(!b){if(c=await Y(a),!c)throw Error(`${a}.js or ${a}.jsx is not found.`);}else if(b.isDirectory()){b=!1;let e;a.endsWith("/")||(e=c=await Y(a),b=!0);if(!e){c=await Y(W(a,"index"));if(!c)throw Error(`${b?`${a}.jsx? does not exist, and `:""}index.jsx? file is not found in ${a}`);d=!0}}return{path:a.startsWith(".")?X("",c):c,K:d}},Y=async a=>{a=`${a}.js`;let b=await U(a);b||(a=`${a}x`);if(b=await U(a))return a};const Ea=async(a,b,c={})=>{const {fields:d,soft:e=!1}=c;var f=W(a,"node_modules",b);f=W(f,"package.json");const h=await U(f);if(h){a=await Da(f,d);if(void 0===a)throw Error(`The package ${X("",f)} does export the module.`);if(!a.entryExists&&!e)throw Error(`The exported module ${a.main} in package ${b} does not exist.`);const {entry:k,version:l,packageName:g,main:m,entryExists:p,...n}=a;return{entry:X("",k),packageJson:X("",f),...l?{version:l}:{},packageName:g,...m?{hasMain:!0}:{},...p?{}:{entryExists:!1},
...n}}if("/"==a&&!h)throw Error(`Package.json for module ${b} not found.`);return Ea(W(Ba(a),".."),b,c)},Da=async(a,b=[])=>{const c=await A(a);let d,e,f,h,k;try{({module:d,version:e,name:f,main:h,...k}=JSON.parse(c)),k=b.reduce((g,m)=>{g[m]=k[m];return g},{})}catch(g){throw Error(`Could not parse ${a}.`);}a=V(a);b=d||h;if(!b){if(!await U(W(a,"index.js")))return;b=h="index.js"}a=W(a,b);let l;try{({path:l}=await Ca(a)),a=l}catch(g){}return{entry:a,version:e,packageName:f,main:!d&&h,entryExists:!!l,
...k}};const Fa=async(a,b,{mount:c,override:d={}})=>{var e=async(f,h,k)=>{var l=V(a);if(/^[/.]/.test(k))return f;{let [p,n,...q]=k.split("/");!p.startsWith("@")&&n?(q=[n,...q],n=p):n=p.startsWith("@")?`${p}/${n}`:p;f={name:n,paths:q.join("/")}}const {name:g,paths:m}=f;if(d[g])return`${h}'${d[g]}'`;({packageJson:l}=await Ea(l,g));f=Ba(l);l=V(f);if(m)return Z(l,m,h,c);({module:f}=require(f));return f?Z(l,f,h,c):(console.warn("[\u219b] Package %s does not specify module in package.json, trying src",l),Z(l,
"src",h))};e=new I([{re:/^( *import(?:\s+[^\s,]+\s*,?)?(?:\s*{(?:[^}]+)})?\s+from\s+)['"](.+)['"]/gm,replacement:e},{re:/^( *import\s+)['"](.+)['"]/gm,replacement:e}]);e.end(b);return await z(e)},Z=(a,b,c,d)=>{a=W(a,b);b=X("",a);d&&(b=X(d,b));return`${c}'/${b}${a.endsWith("/")?"/":""}'`};const Ga=async(a,b,c,{mount:d,override:e})=>{/\.jsx$/.test(a)&&(b=Aa(b),c&&(b=`${c}\n${b}`));return b=/\.css$/.test(a)?`function __$styleInject(css = '') {
  const head = document.head
  const style = document.createElement('style')
  style.type = 'text/css'
  if (style.styleSheet){
    style.styleSheet.cssText = css
  } else {
    style.appendChild(document.createTextNode(css))
  }
  head.appendChild(style)
}
const style = \`${b}\`
__$styleInject(style)`:await Fa(a,b,{mount:d,override:e})};module.exports=function(a={}){const {directory:b="frontend",pragma:c="import { h } from 'preact'",mount:d=".",override:e={}}=a;let {log:f}=a;!0===f&&(f=console.log);const h=Array.isArray(b)?b:[b];h.forEach(k=>{const l=W(d,k);if(!ba(l))throw Error(`Frontend directory ${k} does not exist.`);});return async(k,l)=>{let g=k.path.replace("/","");if(!(h.includes(g)||h.some(x=>g.startsWith(`${x}/`))||k.path.startsWith("/node_modules/")))return await l();g=W(d,g);const {path:m,K:p}=await Ca(g);if(p&&!g.endsWith("/"))l=
d?X(d,m):m,k.redirect(`/${l}`);else{try{var n=await T(r,m)}catch(x){k.status=404;return}k.status=200;k.etag=`${n.mtime.getTime()}`;if(k.fresh)return k.status=304,await l();l=await A(m);n=(new Date).getTime();l=await Ga(m,l,c,{mount:d,override:e});var q=(new Date).getTime();f&&f("%s patched in %sms",m,q-n);k.type="application/javascript";k.body=l}}};

//# sourceMappingURL=front-end.js.map