#!/usr/bin/env node
             
const fs = require('fs');
const path = require('path');
const os = require('os');
const stream = require('stream');
const vm = require('vm');             const aa=fs.createReadStream,ba=fs.existsSync,t=fs.lstat;var ca=stream;const da=stream.Transform,ea=stream.Writable;const w=(a,b=0,c=!1)=>{if(0===b&&!c)return a;a=a.split("\n",c?b+1:void 0);return c?a[a.length-1]:a.slice(b).join("\n")},fa=(a,b=!1)=>w(a,2+(b?1:0)),x=a=>{({callee:{caller:a}}=a);return a};const ha=os.EOL,ia=os.homedir;const y=/\s+at.*(?:\(|\s)(.*)\)?/,ja=/^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:IGNORED_MODULES)\/.*)?\w+)\.js:\d+:\d+)|native)/,ka=ia(),z=a=>{const {pretty:b=!1,ignoredModules:c=["pirates"]}={},d=c.join("|"),f=new RegExp(ja.source.replace("IGNORED_MODULES",d));return a.replace(/\\/g,"/").split("\n").filter(e=>{e=e.match(y);if(null===e||!e[1])return!0;e=e[1];return e.includes(".app/Contents/Resources/electron.asar")||e.includes(".app/Contents/Resources/default_app.asar")?!1:!f.test(e)}).filter(e=>
e.trim()).map(e=>b?e.replace(y,(h,g)=>h.replace(g,g.replace(ka,"~"))):e).join("\n")};function la(a,b,c=!1){return function(d){var f=x(arguments),{stack:e}=Error();const h=w(e,2,!0),g=(e=d instanceof Error)?d.message:d;f=[`Error: ${g}`,...null!==f&&a===f||c?[b]:[h,b]].join("\n");f=z(f);return Object.assign(e?d:Error(),{message:g,stack:f})}};function A(a){var {stack:b}=Error();const c=x(arguments);b=fa(b,a);return la(c,b,a)};const ma=(a,b)=>{b.once("error",c=>{a.emit("error",c)});return b};class na extends ea{constructor(a){const {binary:b=!1,rs:c=null,...d}=a||{},{H:f=A(!0),proxyError:e}=a||{},h=(g,l)=>f(l);super(d);this.a=[];this.C=new Promise((g,l)=>{this.on("finish",()=>{let k;b?k=Buffer.concat(this.a):k=this.a.join("");g(k);this.a=[]});this.once("error",k=>{if(-1==k.stack.indexOf("\n"))h`${k}`;else{const p=z(k.stack);k.stack=p;e&&h`${k}`}l(k)});c&&ma(this,c).pipe(this)})}_write(a,b,c){this.a.push(a);c()}get j(){return this.C}}const B=async a=>{({j:a}=new na({rs:a,H:A(!0)}));return await a};async function C(a){a=aa(a);return await B(a)};const oa=vm.Script;const pa=(a,b)=>{const [c,,d]=a.split("\n");a=parseInt(c.replace(/.+?(\d+)$/,(e,h)=>h))-1;const f=d.indexOf("^");({length:b}=b.split("\n").slice(0,a).join("\n"));return b+f+(a?1:0)};const D=a=>{try{new oa(a)}catch(b){const c=b.stack;if(!/Unexpected token '?</.test(b.message))throw b;return pa(c,a)}return null};function E(a){if("object"!=typeof a)return!1;const b=a.re instanceof RegExp;a=-1!=["string","function"].indexOf(typeof a.replacement);return b&&a}const F=(a,b)=>{if(!(b instanceof Error))throw b;[,,a]=a.stack.split("\n",3);a=b.stack.indexOf(a);if(-1==a)throw b;a=b.stack.substr(0,a-1);const c=a.lastIndexOf("\n");b.stack=a.substr(0,c);throw b;};function G(a,b){function c(){return b.filter(E).reduce((d,{re:f,replacement:e})=>{if(this.b)return d;if("string"==typeof e)return d=d.replace(f,e);{let h;return d.replace(f,(g,...l)=>{h=Error();try{return this.b?g:e.call(this,g,...l)}catch(k){F(h,k)}})}},`${a}`)}c.a=()=>{c.b=!0};return c.call(c)};const qa=a=>new RegExp(`%%_RESTREAM_${a.toUpperCase()}_REPLACEMENT_(\\d+)_%%`,"g"),ra=(a,b)=>`%%_RESTREAM_${a.toUpperCase()}_REPLACEMENT_${b}_%%`,H=(a,b)=>Object.keys(a).reduce((c,d)=>{{var f=a[d];const {getReplacement:e=ra,getRegex:h=qa}=b||{},g=h(d);f={name:d,re:f,regExp:g,getReplacement:e,map:{},lastIndex:0}}return{...c,[d]:f}},{}),I=a=>{var b=[];const c=a.map;return{re:a.regExp,replacement(d,f){d=c[f];delete c[f];return G(d,Array.isArray(b)?b:[b])}}},J=a=>{const b=a.map,c=a.getReplacement,d=a.name;
return{re:a.re,replacement(f){const e=a.lastIndex;b[e]=f;a.lastIndex+=1;return c(d,e)}}};async function sa(a,b){return ta(a,b)}
class K extends da{constructor(a,b){super(b);this.a=(Array.isArray(a)?a:[a]).filter(E);this.b=!1;this.j=b}async replace(a,b){const c=new K(this.a,this.j);b&&Object.assign(c,b);a=await sa(c,a);c.b&&(this.b=!0);b&&Object.keys(b).forEach(d=>{b[d]=c[d]});return a}async reduce(a){return await this.a.reduce(async(b,{re:c,replacement:d})=>{b=await b;if(this.b)return b;if("string"==typeof d)b=b.replace(c,d);else{const f=[];let e;const h=b.replace(c,(g,...l)=>{e=Error();try{if(this.b)return f.length?f.push(Promise.resolve(g)):
g;const k=d.call(this,g,...l);k instanceof Promise&&f.push(k);return k}catch(k){F(e,k)}});if(f.length)try{const g=await Promise.all(f);b=b.replace(c,()=>g.shift())}catch(g){F(e,g)}else b=h}return b},`${a}`)}async _transform(a,b,c){try{const d=await this.reduce(a);this.push(d);c()}catch(d){a=z(d.stack),d.stack=a,c(d)}}}async function ta(a,b){b instanceof ca?b.pipe(a):a.end(b);return await B(a)};const ua=a=>{[,a]=/<\s*(.+?)(?:\s+[\s\S]+)?\s*\/?\s*>/.exec(a)||[];return a},M=(a,{s:b=!1,classNames:c=[],renameMap:d={}}={})=>{let f=0;const e=[];let h;G(a,[{re:/[{}]/g,replacement(m,n){m="}"==m;const r=!m;if(!f&&m)throw Error("A closing } is found without opening one.");f+=r?1:-1;1==f&&r?h={open:n}:0==f&&m&&(h.close=n,e.push(h),h={})}}]);if(f)throw Error(`Unbalanced props (level ${f}) ${a}`);const g={},l=[],k={};var p=e.reduce((m,{open:n,close:r})=>{m=a.slice(m,n);const [,u,v,Aa,Ba]=/(\s*)(\S+)(\s*)=(\s*)$/.exec(m)||
[];n=a.slice(n+1,r);if(!v&&!/\s*\.\.\./.test(n))throw Error("Could not detect prop name");v?g[v]=n:l.push(n);k[v]={before:u,v:Aa,u:Ba};n=m||"";n=n.slice(0,n.length-(v||"").length-1);const {o:Ca,h:Da}=L(n);Object.assign(g,Ca);Object.assign(k,Da);return r+1},0);if(e.length){p=a.slice(p);const {o:m,h:n}=L(p);Object.assign(g,m);Object.assign(k,n)}else{const {o:m,h:n}=L(a);Object.assign(g,m);Object.assign(k,n)}let q=g;if(b||Array.isArray(c)&&c.length||Object.keys(c).length){({...q}=g);const m=[];Object.keys(q).forEach(n=>
{const r=()=>{m.push(n);delete q[n]};if(Array.isArray(c)&&c.includes(n))r();else if(c[n])r();else if(b){const u=n[0];u.toUpperCase()==u&&r()}});m.length&&(p=m.map(n=>n in d?d[n]:n).join(" "),q.className?/[`"']$/.test(q.className)?q.className=q.className.replace(/([`"'])$/,` ${p}$1`):q.className+=`+' ${p}'`:q.g?/[`"']$/.test(q.g)?q.g=q.g.replace(/([`"'])$/,` ${p}$1`):q.g+=`+' ${p}'`:q.className=`'${p}'`)}return{m:q,l,h:k}},L=a=>{const b=[],c={};a.replace(/(\s*)(\S+)(\s*)=(\s*)(["'])([\s\S]*?)\5/g,
(d,f,e,h,g,l,k,p)=>{c[e]={before:f,v:h,u:g};b.push({i:p,name:e,B:`${l}${k}${l}`});return"%".repeat(d.length)}).replace(/(\s*)([^\s%]+)/g,(d,f,e,h)=>{c[e]={before:f};b.push({i:h,name:e,B:"true"})});return{o:[...b.reduce((d,{i:f,name:e,B:h})=>{d[f]=[e,h];return d},[])].filter(Boolean).reduce((d,[f,e])=>{d[f]=e;return d},{}),h:c}},va=(a,b=[],c=!1,d={},f="")=>{const e=Object.keys(a);return e.length||b.length?`{${e.reduce((h,g)=>{const l=a[g],k=c||-1!=g.indexOf("-")?`'${g}'`:g,{before:p="",v:q="",u:m=
""}=d[g]||{};return[...h,`${p}${k}${q}:${m}${l}`]},b).join(",")}${f}}`:"{}"},wa=(a="")=>{[a]=a;if(!a)throw Error("No tag name is given");return a.toUpperCase()==a},N=(a,b={},c=[],d=[],f=!1,e=null,h={},g="")=>{const l=wa(a),k=l?a:`'${a}'`;if(!Object.keys(b).length&&!c.length&&!d.length)return`h(${k})`;const p=l&&"dom"==f?!1:f;l||!d.length||f&&"dom"!=f||e&&e(`JSX: destructuring ${d.join(" ")} is used without quoted props on HTML ${a}.`);a=va(b,d,p,h,g);b=c.reduce((q,m,n)=>{n=c[n-1];let r="";n&&/^\/\*[\s\S]*\*\/$/.test(n)?
r="":n&&/\S/.test(n)&&(r=",");return`${q}${r}${m}`},"");return`h(${k},${a}${b?`,${b}`:""})`};const O=(a,b=[])=>{let c=0,d;a=G(a,[...b,{re:/[<>]/g,replacement(f,e){if(d)return f;const h="<"==f;c+=h?1:-1;0==c&&!h&&(d=e);return f}}]);if(c)throw Error(1);return{N:a,w:d}},Q=a=>{const b=ua(a);let c;const {D:d}=H({D:/=>/g});try{({N:l,w:c}=O(a,[J(d)]))}catch(k){if(1===k)throw Error(`Could not find the matching closing > for ${b}.`);}const f=l.slice(0,c+1);var e=f.replace(/<\s*[^\s/>]+/,"");if(/\/\s*>$/.test(e))return a=e.replace(/\/\s*>$/,""),e="",new P({f:f.replace(d.regExp,"=>"),c:a.replace(d.regExp,
"=>"),content:"",tagName:b});a=e.replace(/>$/,"");e=c+1;c=!1;let h=1,g;G(l,[{re:new RegExp(`[\\s\\S](?:<\\s*${b}(\\s+|>)|/\\s*${b}\\s*>)`,"g"),replacement(k,p,q,m){if(c)return k;p=!p&&k.endsWith(">");const n=!p;if(n){m=m.slice(q);const {w:r}=O(m.replace(/^[\s\S]/," "));m=m.slice(0,r+1);if(/\/\s*>$/.test(m))return k}h+=n?1:-1;0==h&&p&&(c=q,g=c+k.length);return k}}]);if(h)throw Error(`Could not find the matching closing </${b}>.`);e=l.slice(e,c);var l=l.slice(0,g).replace(d.regExp,"=>");return new P({f:l,
c:a.replace(d.regExp,"=>"),content:e.replace(d.regExp,"=>"),tagName:b})};class P{constructor(a){this.f=a.f;this.c=a.c;this.content=a.content;this.tagName=a.tagName}};const R=a=>{let b="",c="";a=a.replace(/^(\r?\n\s*)([\s\S]+)?/,(d,f,e="")=>{b=f;return e}).replace(/([\s\S]+?)?(\r?\n\s*)$/,(d,f="",e="")=>{c=e;return f});return`${b}${a?`\`${a}\``:""}${c}`},ya=a=>{const b=[];let c={},d=0,f=0;G(a,[{re:/[<{}]/g,replacement(e,h){if(!(h<f))if(/[{}]/.test(e))d+="{"==e?1:-1,1==d&&void 0==c.from?c.from=h:0==d&&(c.A=h+1,c.I=a.slice(c.from+1,h),b.push(c),c={});else{if(d)return e;e=Q(a.slice(h));f=h+e.f.length;c.J=e;c.A=f;c.from=h;b.push(c);c={}}}},{}]);return b.length?xa(a,
b):[R(a)]},xa=(a,b)=>{let c=0;b=b.reduce((d,{from:f,A:e,I:h,J:g})=>{(f=a.slice(c,f))&&d.push(R(f));c=e;h?d.push(h):g&&d.push(g);return d},[]);if(c<a.length){const d=a.slice(c,a.length);d&&b.push(R(d))}return b};const za=(a,b={})=>{var c=b.quoteProps,d=b.warn;const f=b.prop2class,e=b.classNames,h=b.renameMap;var g=D(a);if(null===g)return a;var l=a.slice(g);const {c:k="",content:p,tagName:q,f:{length:m}}=Q(l);l=S(p,c,d,b);const {m:n,l:r,h:u}=M(k.replace(/^ */,""),{s:f,classNames:e,renameMap:h});d=N(q,n,l,r,c,d,u,/\s*$/.exec(k)||[""]);c=a.slice(0,g);a=a.slice(g+m);g=m-d.length;0<g&&(d=`${" ".repeat(g)}${d}`);a=`${c}${d}${a}`;return za(a,b)},S=(a,b=!1,c=null,d={})=>a?ya(a).reduce((f,e)=>{if(e instanceof P){const {c:l=
"",content:k,tagName:p}=e,{m:q,l:m}=M(l,{s:d.prop2class,classNames:d.classNames,renameMap:d.renameMap});e=S(k,b,c,d);e=N(p,q,e,m,b,c);return[...f,e]}const h=D(e);if(h){var g=e.slice(h);const {f:{length:l},c:k="",content:p,tagName:q}=Q(g),{m,l:n}=M(k,{s:d.prop2class,classNames:d.classNames,renameMap:d.renameMap});g=S(p,b,c,d);g=N(q,m,g,n,b,c);const r=e.slice(0,h);e=e.slice(h+l);return[...f,`${r}${g}${e}`]}return[...f,e]},[]):[];const Ea=(a,b={})=>{const {e:c,F:d,G:f,i:e,K:h,L:g}=H({F:/^ *export\s+default\s+{[\s\S]+?}/mg,e:/^ *export\s+(?:default\s+)?/mg,G:/^ *export\s+{[^}]+}\s+from\s+(['"])(?:.+?)\1/mg,i:/^ *import(\s+([^\s,]+)\s*,?)?(\s*{(?:[^}]+)})?\s+from\s+['"].+['"]/gm,K:/^ *import\s+(?:(.+?)\s*,\s*)?\*\s+as\s+.+?\s+from\s+['"].+['"]/gm,L:/^ *import\s+['"].+['"]/gm},{getReplacement(l,k){return`/*%%_RESTREAM_${l.toUpperCase()}_REPLACEMENT_${k}_%%*/`},getRegex(l){return new RegExp(`/\\*%%_RESTREAM_${l.toUpperCase()}_REPLACEMENT_(\\d+)_%%\\*/`,
"g")}});a=G(a,[J(f),J(d),J(c),J(e),J(h),J(g)]);b=za(a,b);return G(b,[I(f),I(d),I(c),I(e),I(h),I(g)])};async function Fa(a,b,c){const d=A(!0);if("function"!=typeof a)throw Error("Function must be passed.");if(!a.length)throw Error(`Function${a.name?` ${a.name}`:""} does not accept any arguments.`);return await new Promise((f,e)=>{const h=(l,k)=>l?(l=d(l),e(l)):f(c||k);let g=[h];Array.isArray(b)?g=[...b,h]:1<Array.from(arguments).length&&(g=[b,h]);a(...g)})};const T=async a=>{try{return await Fa(t,a)}catch(b){return null}};const U=path.dirname,V=path.join,Ga=path.parse,W=path.relative,Ha=path.resolve;const Ia=async a=>{var b=await T(a);let c=a,d=!1;if(!b){if(c=await X(a),!c)throw Error(`${a}.js or ${a}.jsx is not found.`);}else if(b.isDirectory()){b=!1;let f;a.endsWith("/")||(f=c=await X(a),b=!0);if(!f){c=await X(V(a,"index"));if(!c)throw Error(`${b?`${a}.jsx? does not exist, and `:""}index.jsx? file is not found in ${a}`);d=!0}}return{path:a.startsWith(".")?W("",c):c,M:d}},X=async a=>{a=`${a}.js`;let b=await T(a);b||(a=`${a}x`);if(b=await T(a))return a};function Ja(a){var b=["className"];const c=[];a.replace(/\.([\w\d_-]+)/g,(d,...f)=>{d=f.slice(0,f.length-2).reduce((e,h,g)=>{g=b[g];if(!g||void 0===h)return e;e[g]=h;return e},{});c.push(d)});return c};let Y;
const La=async(a,b,c={})=>{Y||({root:Y}=Ga(process.cwd()));const {fields:d,soft:f=!1}=c;var e=V(a,"node_modules",b);e=V(e,"package.json");const h=await T(e);if(h){a=await Ka(e,d);if(void 0===a)throw Error(`The package ${W("",e)} does export the module.`);if(!a.entryExists&&!f)throw Error(`The exported module ${a.main} in package ${b} does not exist.`);const {entry:g,version:l,packageName:k,main:p,entryExists:q,...m}=a;return{entry:W("",g),packageJson:W("",e),...l?{version:l}:{},packageName:k,...p?
{hasMain:!0}:{},...q?{}:{entryExists:!1},...m}}if(a==Y&&!h)throw Error(`Package.json for module ${b} not found.`);return La(V(Ha(a),".."),b,c)},Ka=async(a,b=[])=>{const c=await C(a);let d,f,e,h,g;try{({module:d,version:f,name:e,main:h,...g}=JSON.parse(c)),g=b.reduce((k,p)=>{k[p]=g[p];return k},{})}catch(k){throw Error(`Could not parse ${a}.`);}a=U(a);b=d||h;if(!b){if(!await T(V(a,"index.js")))return;b=h="index.js"}a=V(a,b);let l;try{({path:l}=await Ia(a)),a=l}catch(k){}return{entry:a,version:f,packageName:e,
main:!d&&h,entryExists:!!l,...g}};const Ma=async(a,b,{mount:c,override:d={}})=>{var f=async(e,h,g)=>{var l=U(a);if(/^[/.]/.test(g))return e;{let [q,m,...n]=g.split("/");!q.startsWith("@")&&m?(n=[m,...n],m=q):m=q.startsWith("@")?`${q}/${m}`:q;e={name:m,paths:n.join("/")}}const {name:k,paths:p}=e;if(d[k])return`${h}'${d[k]}'`;({packageJson:l}=await La(l,k));e=Ha(l);l=U(e);if(p)return Z(l,p,h,c);({module:e}=require(e));return e?Z(l,e,h,c):(console.warn("[\u219b] Package %s does not specify module in package.json, trying src",l),Z(l,
"src",h))};f=new K([{re:/^( *import(?:\s+[^\s,]+\s*,?)?(?:\s*{(?:[^}]+)})?\s+from\s+)['"](.+)['"]/gm,replacement:f},{re:/^( *import\s+)['"](.+)['"]/gm,replacement:f}]);f.end(b);return await B(f)},Z=(a,b,c,d)=>{a=V(a,b);b=W("",a);d&&(b=W(d,b));return`${c}'/${b}${a.endsWith("/")?"/":""}'`};function Na(a=""){const b=document.head,c=document.createElement("style");c.type="text/css";c.styleSheet?c.styleSheet.cssText=a:c.appendChild(document.createTextNode(a));b.appendChild(c)};const Pa=async(a,b,c,d)=>{const f=d.jsxOptions,e=d.exportClasses;/\.jsx$/.test(a)&&(b=Ea(b,f),c&&(b=`${c}\n${b}`));return b=/\.css$/.test(a)?Oa(b,e):await Ma(a,b,d)},Oa=(a,b=!0)=>{let c=[];b&&(b=a.split(/\r?\n/).filter(d=>/^\S/.test(d)).join(ha),c=Ja(b).map(({className:d})=>d).filter((d,f,e)=>e.indexOf(d)==f));return`(${Na.toString()})(\`${a}\`)
${c.map(d=>`export const $${d} = '${d}'`).join("\n")}`.trim()};module.exports=function(a={}){const {directory:b="frontend",pragma:c="import { h } from 'preact'",mount:d=".",override:f={},jsxOptions:e,exportClasses:h=!0}=a;let {log:g}=a;!0===g&&(g=console.log);const l=Array.isArray(b)?b:[b];l.forEach(k=>{const p=V(d,k);if(!ba(p))throw Error(`Frontend directory ${k} does not exist.`);});return async(k,p)=>{let q=k.path.replace("/","");if(!(l.includes(q)||l.some(v=>q.startsWith(`${v}/`))||k.path.startsWith("/node_modules/")))return await p();q=V(d,q);const {path:m,
M:n}=await Ia(q);if(n&&!q.endsWith("/"))p=d?W(d,m):m,k.redirect(`/${p}`);else{try{var r=await Fa(t,m)}catch(v){k.status=404;return}k.status=200;k.etag=`${r.mtime.getTime()}`;if(k.fresh)return k.status=304,await p();p=await C(m);r=(new Date).getTime();p=await Pa(m,p,c,{mount:d,override:f,jsxOptions:e,exportClasses:h});var u=(new Date).getTime();g&&g("%s patched in %sms",m,u-r);k.type="application/javascript";k.body=p}}};

//# sourceMappingURL=front-end.js.map