{
"version":3,
"file":"compile/front-end.js",
"lineCount":37,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/vm/index.js","node_modules/@a-la/detect-jsx/src/lib/index.js","node_modules/@a-la/detect-jsx/src/index.js","node_modules/restream/src/lib/index.js","node_modules/restream/src/SyncReplaceable.js","node_modules/restream/src/lib/markers.js","node_modules/restream/src/Replaceable.js","node_modules/@a-la/jsx/src/lib/index.js","node_modules/@a-la/jsx/src/lib/extract.js","node_modules/@a-la/jsx/src/lib/parse-content.js","node_modules/@a-la/jsx/src/lib/components.js","node_modules/@a-la/jsx/src/index.js","node_modules/makepromise/src/index.js","node_modules/@wrote/exists/src/index.js","node_modules/path/index.js","node_modules/resolve-dependency/src/index.js","node_modules/fpj/src/index.js","src/lib/index.js","node_modules/@depack/split/src/index.js","src/index.js","src/depack.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","export default vm\nexport const {\n  Script,\n  createContext,\n  isContext,\n  runInContext,\n  runInDebugContext,\n  runInNewContext,\n  runInThisContext,\n} = vm","/**\n * The function to extract the position of the symbol from the error due to the fact that the script body couldn't be evaluated by the _vm.Script_ constructor.\n * @param {string} stack The error stack.\n * @param {string} input The input which was passed to the evaluation.\n */\nexport const findPosition = (stack, input) => {\n  const [h, , l2] = stack.split('\\n')\n  const l = parseInt(h.replace(/.+?(\\d+)$/, (m, d) => d)) - 1\n  const c = l2.indexOf('^')\n  const { length } = input.split('\\n').slice(0, l).join('\\n')\n  const lb = length + c + (l ? 1 : 0)\n  return lb\n}","import { Script } from 'vm'\nimport { findPosition } from './lib'\n\n/**\n * Returns the index of the opening `<` symbol in a JSX tag by calling a Script constructor and extracting information from the error message.\n * @param {string} input The string to evaluate in the V8 VM as JavaScript with JSX. If there is no `<`, the `null` is returned. Any another error in code will be thrown as is.\n */\nconst detectJSX = (input) => {\n  try {\n    new Script(input)\n  } catch (err) {\n    const { message, stack } = err\n    if (!/Unexpected token '?</.test(message)) throw err\n    const bl = findPosition(stack, input)\n    return bl\n  }\n  return null\n}\n\nexport default detectJSX\n\n/* documentary types/index.xml */\n/**\n * @typedef {Object} Config Options for the program.\n * @prop {boolean} [shouldRun=true] A boolean option. Default `true`.\n * @prop {string} text A text to return.\n */\n","export function checkRule(reObject) {\n  if (typeof reObject != 'object') {\n    return false\n  }\n  const { re, replacement } = reObject\n  const hasRe = re instanceof RegExp\n  const type = ['string', 'function'].indexOf(typeof replacement) != -1\n  return hasRe && type\n}\n\nexport const hideStack = (commonError, thrownError) => {\n  if (!(thrownError instanceof Error)) throw thrownError\n  const [, , commonLine] = commonError.stack.split('\\n', 3)\n  const i = thrownError.stack.indexOf(commonLine)\n  if (i == -1) throw thrownError\n  const stack = thrownError.stack.substr(0, i - 1)\n  const li = stack.lastIndexOf('\\n')\n  thrownError.stack = stack.substr(0, li)\n  throw thrownError\n}","import { checkRule, hideStack } from './lib'\n\n/**\n  * _SyncReplaceable_ function receives the whole string and returns the result of transform rules which are either sync function replacers or string replacements (see https://github.com/artdecocode/restream#rule-type for more info). This is not a class and just a function.\n  * @param {string|!Buffer} input The string or buffer to transform synchronously using the replacements. Does not support asynchronous replacements.\n  * @param {!Array<!_restream.Rule>} rules An array with rules.\n  * @return {string}\n  * @example\n```\n// markdown __ to html <em> implementation\nconst stream = SyncReplaceable('__hello world__', {\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n  */\nfunction SyncReplaceable(input, rules) {\n  /**\n   * @suppress {globalThis}\n   */\n  function replace() {\n    const fr = rules.filter(checkRule)\n    const s = fr.reduce((acc, { re, replacement }) => {\n      /** @type {string} */\n      let Acc = acc\n      if (this._broke) return Acc\n\n      if (typeof replacement == 'string') {\n        Acc = Acc.replace(re, replacement)\n        return Acc\n      } else {\n        let commonError\n        const t = Acc.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) return match\n            const p = replacement.call(this, match, ...args)\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        return t\n      }\n    }, `${input}`)\n    return s\n  }\n  replace.brake = () => { replace._broke = true }\n  return replace.call(replace)\n}\n\nexport default SyncReplaceable\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */","import SyncReplaceable from '../SyncReplaceable'\n\n/**\n * @param {string} name\n */\nconst getDefaultRegExp = (name) => {\n  return new RegExp(`%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%`, 'g')\n}\n\n/**\n * Make a unique string to replace cut text with.\n * @param {string} name\n * @param {number} index\n */\nconst getDefaultReplacement = (name, index) => {\n  return `%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%`\n}\n\n/**\n * Create a new marker.\n * @param {string} name The name of the matcher, used in the doc marker.\n * @param {!RegExp} re The regular expression used for detection.\n * @param {!_restream.MakeMarkersConfig} [conf] Additional configuration.\n * @param {function(string, number): string} [conf.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [conf.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @return {!_restream.Marker} The marker.\n */\nconst makeMarker = (name, re, conf) => {\n  const {\n    getReplacement = getDefaultReplacement,\n    getRegex = getDefaultRegExp,\n  } = conf || {}\n  const regExp = getRegex(name)\n  return {\n    name,\n    re,\n    regExp,\n    getReplacement,\n    map: {},\n    lastIndex: 0,\n  }\n}\n\n/**\n * Make markers from a configuration object.\n * @param {!Object.<string, !RegExp>} matchers An object with types of markers to create as keys and their detection regexes as values.\n * @param {!_restream.MakeMarkersConfig} [config] Additional configuration.\n * @param {function(string, number): string} [config.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [config.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @returns {!Object.<string, !_restream.Marker>} An object with markers for each requested type.\n */\nexport const makeMarkers = (matchers, config) => {\n  const res = Object.keys(matchers).reduce((acc, key) => {\n    const re = matchers[key]\n    const marker = makeMarker(key, re, config)\n    const m = {\n      ...acc,\n      [key]: marker,\n    }\n    return m\n  }, {})\n  return res\n}\n\n/**\n * Make a rule for pasting markers back.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @param {!(_restream.Rule|Array<!_restream.Rule>)} [pipeRules] Any additional rules to replace the value of the marker before pasting it.\n * @returns {!_restream.Rule} A rule to paste previously replaced chunks.\n */\nexport const makePasteRule = (marker, pipeRules = []) => {\n  const { regExp: re, map } = marker\n  const rule = {\n    re,\n    replacement(match, index) {\n      const m = map[index]\n      delete map[index]\n      const pr = Array.isArray(pipeRules) ? pipeRules : [pipeRules]\n      const res = SyncReplaceable(m, pr)\n      return res\n    },\n  }\n  return rule\n}\n\n/**\n * Make a rule for initial replacement of markers.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @returns {!_restream.Rule} A rule to cut matched chunks.\n */\nexport const makeCutRule = (marker) => {\n  const { re, map, getReplacement, name } = marker\n  const rule = {\n    re,\n    replacement(match) {\n      const { lastIndex } = marker\n      map[lastIndex] = match\n      marker.lastIndex += 1\n      const m = getReplacement(name, lastIndex)\n      return m\n    },\n  }\n  return rule\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */\n\n/* documentary types/markers.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.Marker} Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @prop {string} name The name of the marker for annotation purposes.\n * @prop {function(string, number): string} getReplacement The function to generate marker placeholders which can be then found, e.g., for (name: `marker`, index: `10`) by default _Restream_ will generate `%%_RESTREAM_MARKER_REPLACEMENT_10_%%`, but can be overriden with this method.\n * @prop {!RegExp} re The regular expression used for detection of the match.\n * @prop {!RegExp} regExp The generated regular expression to replace the marker back to its original value.\n * @prop {!Object<number, string>} map The map which holds detected matches at their indexes.\n * @prop {number} lastIndex The index of the last inserted element. Starts with 0.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.MakeMarkersConfig} MakeMarkersConfig Additional configuration.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.MakeMarkersConfig Additional configuration.\n * @prop {function(string, number): string} [getReplacement] The function used to create a replacement when some text needs to be cut.\n * @prop {function(string): !RegExp} [getRegex] The function used to create a RegExp to detect replaced chunks.\n */\n","import Stream, { Transform } from 'stream'\nimport cleanStack from '@artdeco/clean-stack'\nimport { collect } from 'catchment'\nimport { checkRule, hideStack } from './lib'\n\nexport default class Replaceable extends Transform {\n  /**\n   * Replaceable class that extends Transform and pushes data when it's done replacing each incoming chunk. If the replacement is passed as a function, it will work in the same way as the replacer for `string.replace` method (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace), taking the `match` as the first argument, and matched `p1`, `p2`, _etc_ parameters as following arguments. The replacer can also be an async function.\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules A single replacement rule, or multiple rules.\n   * @param {!stream.TransformOptions} [options] The options for the transform stream.\n   * @example\n   *\n```\n// markdown __ to html <em> implementation\nconst stream = replaceStream({\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n   */\n  constructor(rules, options) {\n    super(options)\n    const re = Array.isArray(rules) ? rules : [rules]\n    const fr = re.filter(checkRule)\n    this.rules = fr\n    /**\n     * Whether the _Replaceable_ will not apply any more rules.\n     * @type {boolean}\n     */\n    this._broke = false\n    this._options = options\n  }\n\n  /**\n   * Creates a new replaceable to replace the given string, buffer or stream using the rules of the current stream. Calling `brake` will also set `_broke` on the parent stream.\n   * @param {string|!Buffer|!Stream} input The input to replace.\n   * @param {!Object} [context] The context to assign to the new replaceable.\n   */\n  async replace(input, context) {\n    const replaceable = new Replaceable(this.rules, this._options)\n    if (context) Object.assign(replaceable, context)\n    const res = await Replaceable.replace(replaceable, input)\n    if (replaceable._broke) this.brake()\n    if (context) Object.keys(context).forEach(key => {\n      context[key] = replaceable[key]\n    })\n    return res\n  }\n  /**\n   * The method to end the stream with given data, and collect the result.\n   * @param {!Replaceable} replaceable\n   * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n   */\n  static async replace(replaceable, input) {\n    return replace(replaceable, input)\n  }\n\n  /**\n   * Stop executing further after the current rule.\n   */\n  brake() {\n    this._broke = true\n  }\n\n  /**\n   * @param {string|!Buffer} chunk The incoming chunk, or an object if the stream was started in object mode.\n   */\n  async reduce(chunk) {\n    /** @type {string} */\n    const s = await this.rules.reduce(async (acc, { re, replacement }) => {\n      /** @type {string} */\n      let string = await acc\n      if (this._broke) return string\n\n      if (typeof replacement == 'string') {\n        string = string.replace(re, replacement)\n      } else {\n        const promises = []\n        let commonError\n        const t = string.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) {\n              if (promises.length)\n                return promises.push(Promise.resolve(match))\n              return match\n            }\n            const p = replacement.call(this, match, ...args)\n            if (p instanceof Promise) {\n              promises.push(p)\n            }\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        if (promises.length) {\n          try { // hide stack only for when throw happens before awaits\n            const data = await Promise.all(promises)\n            string = string.replace(re, () => data.shift())\n          } catch (e) {\n            hideStack(commonError, e)\n          }\n        } else {\n          string = t\n        }\n      }\n      return string\n    }, `${chunk}`)\n\n    return s\n  }\n  /**\n   * @suppress {checkTypes}\n   * @returns {!Promise}\n   */\n  async _transform(chunk, _, next) {\n    try {\n      const s = await this.reduce(chunk)\n      this.push(s)\n      next()\n    } catch (e) {\n      const s = cleanStack(e.stack)\n      e.stack = s\n      next(e)\n    }\n  }\n}\n\n/**\n * The method to end the stream with given data, and collect the result.\n * @param {!Replaceable} replaceable\n * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n */\nexport async function replace(replaceable, input) {\n  if (input instanceof Stream) {\n    input.pipe(replaceable)\n  } else {\n    replaceable.end(input)\n  }\n  /** @type {string} */\n  const data = await collect(replaceable)\n  return data\n}\n\n/**\n * The class for when serial execution of asynchronous replacements withing the same rule are needed.\n */\nexport class SerialAsyncReplaceable extends Replaceable {\n  /**\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules\n   */\n  constructor(rules) {\n    super(rules)\n    this.promise = Promise.resolve()\n  }\n  addItem(fn) {\n    const pp = this.promise.then(fn)\n    this.promise = pp\n    return pp\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Rule} _restream.Rule\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').AsyncReplacer} _restream.AsyncReplacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Replacer} _restream.Replacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').TransformOptions} stream.TransformOptions\n */","import { SyncReplaceable } from 'restream'\r\n\r\n/**\r\n * Returns the name of the opening tag from the string starting with <, or `undefined`.\r\n * @param {string} string The string where to find the tag.\r\n * @example\r\n * const s = '<div>hello world</div>'\r\n * const tag = getTagName(s) // div\r\n */\r\nexport const getTagName = (string) => {\r\n  const [, tagName] = /<\\s*(.+?)(?:\\s+[\\s\\S]+)?\\s*\\/?\\s*>/.exec(string) || []\r\n  return tagName\r\n}\r\n\r\n// * const getClass = o => Object.keys(o).join(' ')\r\n\r\n/**\r\n * Parses a string with attributes written in jsx, e.g., `id={id}` into an object.\r\n * @param {string} props The string with properties in the tag\r\n * @example\r\n *\r\n * const El = getProps(\"class={'hello world'} id={id}\")\r\n * // =>\r\n   {\r\n     class: \"'hello world'\",\r\n     id: 'id'\r\n    }\r\n *\r\n */\r\nexport\r\nconst getProps = (props) => {\r\n  let stack = 0\r\n  const positions = []\r\n  let current\r\n  SyncReplaceable(props, [\r\n    {\r\n      re: /[{}]/g,\r\n      replacement(m, i) {\r\n        const closing = m == '}'\r\n        const opening = !closing\r\n        if (!stack && closing)\r\n          throw new Error('A closing } is found without opening one.')\r\n        stack += opening ? 1 : -1\r\n        if (stack == 1 && opening) {\r\n          current = {\r\n            open: i,\r\n          }\r\n        } else if (stack == 0 && closing) {\r\n          current.close = i\r\n          positions.push(current)\r\n          current = {}\r\n        }\r\n      },\r\n    },\r\n  ])\r\n  if (stack) throw new Error(`Unbalanced props (level ${stack}) ${props}`)\r\n  const obj = {}\r\n  const destructuring = []\r\n  const whitespace = {}\r\n  const lastClose = positions.reduce((acc, { open, close }) => {\r\n    const before = props.slice(acc, open)\r\n    const [, wsBefore, propName, wsBeforeAssign, afterAssign] = /(\\s*)(\\S+)(\\s*)=(\\s*)$/.exec(before) || []\r\n    const val = props.slice(open + 1, close)\r\n    if (!propName && !/\\s*\\.\\.\\./.test(val))\r\n      throw new Error('Could not detect prop name')\r\n    if (!propName) {\r\n      destructuring.push(val)\r\n    } else {\r\n      obj[propName] = val\r\n    }\r\n    whitespace[propName] = { before: wsBefore, beforeAssign: wsBeforeAssign, afterAssign }\r\n    const beforeOrNot = before || '' // when using destructuring\r\n    const propOrNot = propName || ''\r\n    const bb = beforeOrNot.slice(0, beforeOrNot.length - propOrNot.length - 1)\r\n    const { plain, whitespace: ws } = getPlain(bb)\r\n    Object.assign(obj, plain)\r\n    Object.assign(whitespace, ws)\r\n    return close + 1\r\n  }, 0)\r\n  // make sure plain attrs are there when no {} are given\r\n  if (!positions.length) {\r\n    const { plain, whitespace: ws } = getPlain(props)\r\n    Object.assign(obj, plain)\r\n    Object.assign(whitespace, ws)\r\n  } else {\r\n    const whatsLeft = props.slice(lastClose)\r\n    const { plain, whitespace: ws } = getPlain(whatsLeft)\r\n    Object.assign(obj, plain)\r\n    Object.assign(whitespace, ws)\r\n  }\r\n  return { obj, destructuring, whitespace }\r\n}\r\n\r\n/**\r\n * Returns the matches without {}, such as `id=\"test\"`.\r\n * @param {string} string The string with plain attributes.\r\n */\r\nconst getPlain = (string) => {\r\n  const r = []\r\n  const whitespace = {}\r\n  const res = string.replace(/(\\s*)(\\S+)(\\s*)=(\\s*)([\"'])([\\s\\S]+?)\\5/g, (m, wsBefore, name, wsBeforeAssign, wsAfterAssign, q, val, i) => {\r\n    whitespace[name] = { before: wsBefore, beforeAssign: wsBeforeAssign, afterAssign: wsAfterAssign }\r\n    r.push({ i, name, val: `${q}${val}${q}` })\r\n    return '%'.repeat(m.length)\r\n  })\r\n  res.replace(/(\\s*)([^\\s%]+)/g, (m, ws, name, i) => {\r\n    whitespace[name] = { before: ws }\r\n    r.push({ i, name, val: 'true' }) // boolean\r\n  })\r\n  const obj = [...r.reduce((acc, { i, name, val }) => {\r\n    acc[i] = [name, val]\r\n    return acc\r\n  }, [])].filter(Boolean).reduce((acc, [name, val]) => {\r\n    acc[name] = val\r\n    return acc\r\n  }, {})\r\n  return { plain: obj, whitespace }\r\n}\r\n\r\n/**\r\n * Accepts the parsed node properties to make a JS object string out of them.\r\n * @param {!Object<string, string>} pp The properties out of which to make a string object.\r\n * @returns {string|null} Either a JS object body string, or null if no keys were in the object.\r\n */\r\nexport\r\nconst makeObjectBody = (pp, destructuring = [], quoteProps = false, whitespace = {}, beforeCloseWs = '') => {\r\n  const keys = Object.keys(pp)\r\n  const { length } = keys\r\n  if (!length && !destructuring.length) return '{}'\r\n  const pr = `{${keys.reduce((a, k) => {\r\n    const v = pp[k]\r\n    const kk = quoteProps || k.indexOf('-') != -1 ? `'${k}'` : k\r\n    const { before = '', beforeAssign = '', afterAssign = '' } = whitespace[k] || {}\r\n    return [...a, `${before}${kk}${beforeAssign}:${afterAssign}${v}`]\r\n  }, destructuring).join(',')}${beforeCloseWs}}`\r\n  return pr\r\n}\r\n\r\nexport const isComponentName = (tagName = '') => {\r\n  const [t] = tagName\r\n  if (!t) throw new Error('No tag name is given')\r\n  return t.toUpperCase() == t\r\n}\r\n\r\n/**\r\n * Creates a string invocation of the pragma function.\r\n * @param {string} tagName The name of the tag to create, or a reference to a component function.\r\n * @param {!Object<string, string>} props The properties of the element. The properties' values can be passed as strings or references as the `e` function will be called under the scope in which the JSX is written, e.g., when creating components `const C = ({ reference }) => <div id={reference} class=\"String\"/>`.\r\n * @param {!Array<string>} children The array with the child nodes which are strings, but encode either a reference, a string or an invocation the the `e` function again. Thus the jsx is parsed recursively depth-first.\r\n * @param {!Array<string>} [destructuring] Any properties for destructuring.\r\n * @param {boolean} [quoteProps=false] Whether to quote the properties' keys (for Closure compiler).\r\n * @example\r\n *\r\n * const r = pragma('div', { id: \"'STATIC_ID'\" }, [\"'Hello, '\", \"test\", \"'!'\"])\r\n * // =>\r\n * e('div',{ id: 'STATIC_ID' },['Hello, ', test, '!'])\r\n */\r\nexport const pragma = (tagName, props = {}, children = [], destructuring = [], quoteProps = false, warn = null, whitespace = {}, beforeCloseWs = '') => {\r\n  const cn = isComponentName(tagName)\r\n  const tn = cn ? tagName : `'${tagName}'`\r\n  if (!Object.keys(props).length && !children.length && !destructuring.length) {\r\n    return `h(${tn})`\r\n  }\r\n  const qp = cn && quoteProps == 'dom' ? false : quoteProps\r\n  if (!cn && destructuring.length && (!quoteProps || quoteProps == 'dom')) {\r\n    warn && warn(`JSX: destructuring ${destructuring.join(' ')} is used without quoted props on HTML ${tagName}.`)\r\n  }\r\n  const pr = makeObjectBody(props, destructuring, qp, whitespace, beforeCloseWs)\r\n  const c = children.reduce((acc, cc, i) => {\r\n    const prev = children[i-1]\r\n    const comma = prev && /\\S/.test(prev) ? ',' : ''\r\n    return `${acc}${comma}${cc}`\r\n  }, '')\r\n  const res = `h(${tn},${pr}${c ? `,${c}` : ''})`\r\n  return res\r\n}\r\n\r\n// export const newPragma = (tagName, ...args) => {\r\n//   return `e('${tagName}',${args.join(',')})`\r\n// }\r\n\r\n// * @todo In strict mode, when the length is more, throws an error. In advanced mode, the replacement should be aligned so it is possible to debug it.\r\n\r\n/**\r\n * Replaces a piece of string inside of a string with another chunk.\r\n * @param {string} input The string inside of which the chunk needs to be replaced.\r\n * @param {number} index The index of the `<` found with `detect-jsx.findPosition`.\r\n * @param {number} length The length of the string that needs to be cut out.\r\n * @param {string} chunk The new string that needs to be placed back into the input.\r\n *\r\n */\r\nexport\r\nconst replaceChunk = (input, index, length, chunk) => {\r\n  const before = input.slice(0, index)\r\n  const after = input.slice(index + length)\r\n  const ld = length - chunk.length\r\n  // if (ld < 0)\r\n  // console.warn('The chunks length is more that replaced input')\r\n  // throw new Error('The length of the chunk cannot be more than of the replaced value.')\r\n  let p = chunk\r\n  if (ld > 0) {\r\n    p = `${' '.repeat(ld)}${p}`\r\n  }\r\n  const res = `${before}${p}${after}`\r\n  return res\r\n}","import { SyncReplaceable, makeMarkers, makeCutRule } from 'restream'\r\nimport { getTagName } from './'\r\n\r\nconst findEnding = (string, rules = []) => {\r\n  let stack = 0\r\n  let contentEnd\r\n  const preString = SyncReplaceable(string, [\r\n    ...rules,\r\n    {\r\n      // once the tag is opened with <, its closing symbol > will always be even (nevermind comments & strings)\r\n      re: /[<>]/g,\r\n      replacement(m, i) {\r\n        if (contentEnd) return m\r\n        const opening = m == '<'\r\n        const closing = !opening\r\n        stack += opening ? 1 : -1\r\n        if (stack == 0 && closing) {\r\n          contentEnd = i\r\n        }\r\n        return m\r\n      },\r\n    },\r\n  ])\r\n  if (stack) throw new Error(1)\r\n  return { preString, contentEnd }\r\n}\r\n\r\n/**\r\n * Returns the outer body of the tag.\r\n * @param {string} stringWithTag The string in which to find the closing tag. Must start with a `<`.\r\n */\r\nconst extract = (stringWithTag) => {\r\n  const tagName = getTagName(stringWithTag)\r\n  let contentEnd\r\n  let props\r\n  const { arrow } = makeMarkers({\r\n    arrow: /=>/g,\r\n  })\r\n  let preString\r\n  try {\r\n    ({ preString, contentEnd } = findEnding(stringWithTag, [ makeCutRule(arrow) ]))\r\n  } catch (err) {\r\n    if (err === 1) throw new Error(`Could not find the matching closing > for ${tagName}.`)\r\n  }\r\n\r\n  const string = preString.slice(0, contentEnd + 1)\r\n  let content = string\r\n    .replace(/<\\s*[^\\s/>]+/, '')\r\n  const selfClosing = /\\/\\s*>$/.test(content)\r\n  if (selfClosing) {\r\n    props = content.replace(/\\/\\s*>$/, '')\r\n    content = ''\r\n    return new ExtractedJSX({\r\n      string: string.replace(arrow.regExp, '=>'),\r\n      props: props.replace(arrow.regExp, '=>'),\r\n      content: '',\r\n      tagName,\r\n    })\r\n  }\r\n  // now find the corresponding closing tag\r\n  props = content.replace(/>$/, '')\r\n  const contentStart = contentEnd + 1\r\n  contentEnd = false\r\n  let stack = 1\r\n  let stringEnd\r\n  SyncReplaceable(preString, [{\r\n    // [\\\\s\\\\S] is to not catch the very beginning\r\n    re: new RegExp(`[\\\\s\\\\S](?:<\\\\s*${tagName}(\\\\s+|>)|/\\\\s*${tagName}\\\\s*>)`, 'g'),\r\n    replacement(m, opensClosing, i, s) {\r\n      if (contentEnd) return m\r\n      const closing = !opensClosing && m.endsWith('>')\r\n      const opening = !closing\r\n\r\n      if (opening) {\r\n        const untilEnd = s.slice(i)\r\n        const { contentEnd: ce } = findEnding(untilEnd\r\n          .replace(/^[\\s\\S]/, ' ')\r\n          // e.g., <span><a /><span></span></span>\r\n          //                 ^\r\n        )\r\n        const t = untilEnd.slice(0, ce + 1)\r\n        const tSelfClosing = /\\/\\s*>$/.test(t)\r\n        if (tSelfClosing) return m\r\n      }\r\n\r\n      stack += opening ? 1 : -1\r\n      if (stack == 0 && closing) {\r\n        contentEnd = i\r\n        stringEnd = contentEnd + m.length\r\n      }\r\n      return m\r\n    },\r\n  }])\r\n  if (stack) throw new Error(`Could not find the matching closing </${tagName}>.`)\r\n  content = preString.slice(contentStart, contentEnd)\r\n  const string2 = preString.slice(0, stringEnd)\r\n    .replace(arrow.regExp, '=>')\r\n\r\n  return new ExtractedJSX({\r\n    string: string2,\r\n    props: props.replace(arrow.regExp, '=>'),\r\n    content: content.replace(arrow.regExp, '=>'),\r\n    tagName,\r\n  })\r\n}\r\n\r\nexport class ExtractedJSX {\r\n  /**\r\n   * @param {{ string: string, props: string, content: string, tagName: string }} properties\r\n   */\r\n  constructor(properties) {\r\n    this.string = properties.string\r\n    this.props = properties.props\r\n    this.content = properties.content\r\n    this.tagName = properties.tagName\r\n  }\r\n}\r\n\r\nexport default extract","import { SyncReplaceable } from 'restream'\r\nimport extract from './extract'\r\n\r\n/**\r\n * Make a quoted string to interpret by JS.\r\n * @param {string} s\r\n * @example\r\n *\r\n * getQuoted('The mind always seeks to equilibrium.')\r\n * // result:\r\n * `The mind always seeks to equilibrium.`\r\n */\r\nexport const getQuoted = (s) => {\r\n  let _b = '', _a = ''\r\n  const r = s\r\n    .replace(/^(\\r?\\n\\s*)([\\s\\S]+)?/, (m, b, v = '') => {\r\n      _b = b\r\n      return v\r\n    })\r\n    .replace(/([\\s\\S]+?)?(\\r?\\n\\s*)$/, (m, v = '', a = '') => {\r\n      _a = a\r\n      return v\r\n    })\r\n  const rr = r ? `\\`${r}\\`` : ''\r\n  return `${_b}${rr}${_a}`\r\n}\r\n\r\n/**\r\n * Returns the array of children for an element by extracting the parts in `{}`.\r\n * @param {string} string\r\n * @example\r\n * parseSimpleContent('Hello, {test}!')\r\n * // result:\r\n * [`Hello, `, test, `!`]\r\n */\r\nexport const parseSimpleContent = (string) => {\r\n  const temps = []\r\n  // let prev = 0\r\n  let current = {}\r\n  let expressionStack = 0\r\n  let jsxStack = 0\r\n  SyncReplaceable(string, [{\r\n    re: /[<{}]/g,\r\n    replacement(m, i) {\r\n      if (i < jsxStack) return // blocked by jsx\r\n      const isExpression = /[{}]/.test(m)\r\n      let opening\r\n      if (isExpression) {\r\n        opening = m == '{'\r\n        expressionStack += opening ? 1 : -1\r\n        if (expressionStack == 1 && current.from == undefined) current.from = i\r\n        else if (expressionStack == 0) {\r\n          current.to = i + 1\r\n          current.expression = string.slice(current.from + 1, i)\r\n          temps.push(current)\r\n          current = {}\r\n        }\r\n      } else {\r\n        if (expressionStack) return m\r\n        const extractedJsx = extract(string.slice(i))\r\n        jsxStack = i + extractedJsx.string.length\r\n        current.extractedJsx = extractedJsx\r\n        current.to = jsxStack\r\n        current.from = i\r\n        temps.push(current)\r\n        current = {}\r\n      }\r\n    },\r\n  }, {\r\n  }])\r\n  const res = temps.length ? getTemps(string, temps) : [getQuoted(string)]\r\n  return res\r\n}\r\n\r\n/**\r\n * Returns the array with broken down string parts either as other strings or expressions.\r\n * @param {string} string The initial string.\r\n * @param {Array<!{from: number, to: number, expression: string }>} temps\r\n * @return {!Array<string>}\r\n * @private This is called by parseSimpleContent.\r\n */\r\nconst getTemps = (string, temps) => {\r\n  let lastTo = 0\r\n  const ar = temps.reduce((acc, { from, to, expression, extractedJsx }) => {\r\n    const b = string.slice(lastTo, from)\r\n    if (b) acc.push(getQuoted(b))\r\n    lastTo = to\r\n    if (expression) acc.push(expression)\r\n    else if (extractedJsx) acc.push(extractedJsx)\r\n    return acc\r\n  }, [])\r\n  if (lastTo < string.length) {\r\n    const a = string.slice(lastTo, string.length)\r\n    // .trim()\r\n    if (a) ar.push(getQuoted(a))\r\n  }\r\n  return ar\r\n}","import detectJSX from '@a-la/detect-jsx'\r\nimport { parseSimpleContent } from './parse-content'\r\nimport { pragma, replaceChunk, getProps } from './'\r\nimport extract, { ExtractedJSX } from './extract'\r\n\r\n\r\n/* <div id={'id'}>\r\n  Hello, {test}! {children}\r\n  <div class={'TEST'} id={id}>test</div>\r\n</div> */\r\n\r\n/**\r\n * The entry point to transpiling a file.\r\n * @param {string} input The string to transpile.\r\n * @returns {string} The transpiled source code with `h` pragma for hyperscript invocations.\r\n */\r\nconst transpileJSX = (input, config = {}) => {\r\n  const { quoteProps, warn } = config\r\n  const position = detectJSX(input)\r\n  if (position === null) return input\r\n\r\n  const s = input.slice(position)\r\n  const { props = '', content, tagName, string: { length } } = extract(s)\r\n  const children = parseContent(content, quoteProps, warn)\r\n  const { obj, destructuring, whitespace } = getProps(props.replace(/^ */, ''))\r\n  const beforeCloseWs = /\\s*$/.exec(props) || ['']\r\n  const f = pragma(tagName, obj, children, destructuring, quoteProps, warn, whitespace, beforeCloseWs)\r\n  const res = replaceChunk(input, position, length, f)\r\n  // find another one one\r\n  const newRes = transpileJSX(res, config)\r\n  return newRes\r\n}\r\n\r\nexport default transpileJSX\r\n\r\n// let f\r\n// if (props) {\r\n//   f = pragma(tagName, prop, children) // `p(tag, { ...props }, children)`\r\n// } else if (children.length == 1) {\r\n//   f = pragma(tagName, children[0]) // `e(tag, child)`\r\n// } else if (children.length) {\r\n//   f = newPragma(tagName, ...children) // `e(tag, child, child2)`\r\n// }\r\n\r\n// parse the content bro parse it\r\n/**\r\n * This function will return an array with content of a jsx tag, and the content can be a function to create an element (pragma), a string, or an expression.\r\n * @param {string} content\r\n * @param {boolean} [quoteProps=false] Whether to quote properties.\r\n */\r\nexport const parseContent = (content, quoteProps = false, warn = null) => {\r\n  if (!content) return []\r\n  // const C = content\r\n  // .split('\\n').filter(a => !/^\\s*$/.test(a)).join('\\n')\r\n  const contents = parseSimpleContent(content) // split by expressions\r\n  const jsx = contents.reduce((acc, string) => {\r\n    if (string instanceof ExtractedJSX) {\r\n      const { props = '', content: part, tagName } = string\r\n      const { obj, destructuring } = getProps(props)\r\n      const children = parseContent(part, quoteProps, warn)\r\n      const p = pragma(tagName, obj, children, destructuring, quoteProps, warn)\r\n      return [...acc, p]\r\n    }\r\n    const j = detectJSX(string)\r\n    if (j) {\r\n      const s = string.slice(j)\r\n      const { string: { length }, props = '', content: part, tagName } = extract(s)\r\n      const { obj, destructuring } = getProps(props)\r\n      const children = parseContent(part, quoteProps, warn)\r\n      const p = pragma(tagName, obj, children, destructuring, quoteProps, warn)\r\n      const strBefore = string.slice(0, j)\r\n      const strAfter = string.slice(j + length)\r\n      return [...acc, `${strBefore}${p}${strAfter}`]\r\n    }\r\n    return [...acc, string]\r\n  }, [])\r\n  return jsx\r\n}","import transpileJSX from './lib/components'\r\nimport { SyncReplaceable,\r\n  makeMarkers, makeCutRule, makePasteRule } from 'restream'\r\n\r\n/**\r\n * Process a JSX file.\r\n * @param {string} input The source code with JSX to transpile.\r\n * @param {!_alaJsx.Config} config Options for the program.\r\n * @param {(boolean|string)} [config.quoteProps=false] Whether to surround property names with quotes. When the `dom` string is passed, it will only quote props for invoking html components, i.e., those that start with a lowercase letter (E.g., for the _Google Closure Compiler_). Default `false`.\r\n * @param {function(...string)} [config.warn] The function to receive warnings, e.g., when destructuring of properties is used on dom elements (for Closure Compiler).\r\n */\r\nconst jsx = (input, config = {}) => {\r\n  const { e, defObj, ef, i, ias, ii } = makeMarkers({\r\n    defObj: /^ *export\\s+default\\s+{[\\s\\S]+?}/mg,\r\n    e: /^ *export\\s+(?:default\\s+)?/mg,\r\n    ef: /^ *export\\s+{[^}]+}\\s+from\\s+(['\"])(?:.+?)\\1/mg,\r\n    i: /^ *import(\\s+([^\\s,]+)\\s*,?)?(\\s*{(?:[^}]+)})?\\s+from\\s+['\"].+['\"]/gm,\r\n    ias: /^ *import\\s+(?:(.+?)\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+['\"].+['\"]/gm,\r\n    ii: /^ *import\\s+['\"].+['\"]/gm,\r\n  }, {\r\n    getReplacement(name, index) {\r\n      return `/*%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%*/`\r\n    },\r\n    getRegex(name) {\r\n      return new RegExp(`/\\\\*%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%\\\\*/`, 'g')\r\n    },\r\n  })\r\n  const s = SyncReplaceable(input, [\r\n    makeCutRule(ef), makeCutRule(defObj), makeCutRule(e),\r\n    makeCutRule(i), makeCutRule(ias), makeCutRule(ii)])\r\n  const tt = transpileJSX(s, config)\r\n  const as = SyncReplaceable(tt, [\r\n    makePasteRule(ef), makePasteRule(defObj), makePasteRule(e),\r\n    makePasteRule(i), makePasteRule(ias), makePasteRule(ii)])\r\n  return as\r\n}\r\n\r\nexport default jsx\r\n\r\n/* documentary types/index.xml */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_alaJsx.Config} Config Options for the program.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _alaJsx.Config Options for the program.\r\n * @prop {(boolean|string)} [quoteProps=false] Whether to surround property names with quotes. When the `dom` string is passed, it will only quote props for invoking html components, i.e., those that start with a lowercase letter (E.g., for the _Google Closure Compiler_). Default `false`.\r\n * @prop {function(...string)} [warn] The function to receive warnings, e.g., when destructuring of properties is used on dom elements (for Closure Compiler).\r\n */\r\n","import erotic from 'erotic'\n\n// /**\n//  * @param {number} length\n//  * @param {number} i\n//  * @param {!Function} fn\n//  */\n// function checkArgumentIndex(length, i, fn) {\n//   if (i > length - 2) {\n//     throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept that many arguments (max ${length - 1} + callback).`)\n//   }\n// }\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn != 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept any arguments.`)\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      // args.forEach((arg, i) => {\n      //   checkArgumentIndex(fnLength, i, fn)\n      // })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      // checkArgumentIndex(fnLength, 0, fn)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","import { join, relative, resolve, dirname, parse } from 'path'\r\nimport exists from '@wrote/exists'\r\nimport read from '@wrote/read'\r\nimport resolveDep from 'resolve-dependency'\r\n\r\nlet ROOT\r\n\r\n/**\r\n * Finds the location of the `package.json` for the given dependency in the directory, and its entry file.\r\n * @param {string} dir The path to the directory where the requiring file is located.\r\n * @param {string} name The name of the required package.\r\n * @param {!_fpj.Config} opts The options for `fpj`.\r\n * @param {!Array<string>} [opts.fields] Any additional fields from `package.json` file to return.\r\n * @param {boolean} [opts.soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\r\n * @returns {!Promise<!_fpj.Return>}\r\n */\r\nconst findPackageJson = async (dir, name, opts = {}) => {\r\n  if (!ROOT) {\r\n    ({ root: ROOT } = parse(process.cwd()))\r\n  }\r\n  const { fields, soft = false } = opts\r\n  const fold = join(dir, 'node_modules', name)\r\n  const path = join(fold, 'package.json')\r\n  const e = await exists(path)\r\n  if (e) {\r\n    const res = await findEntry(path, fields)\r\n    if (res === undefined)\r\n      throw new Error(`The package ${relative('', path)} does export the module.`)\r\n    else if (!res.entryExists && !soft)\r\n      throw new Error(`The exported module ${res.main} in package ${name} does not exist.`)\r\n    const { entry, version, packageName, main, entryExists, ...rest } = res\r\n    const result = /** @type {!_fpj.Return} */ ({\r\n      entry: relative('', entry),\r\n      packageJson: relative('', path),\r\n      ...(version ? { version } : {}),\r\n      packageName,\r\n      ...(main ? { hasMain: true } : {}),\r\n      ...(!entryExists ? { entryExists: false } : {}),\r\n      ...rest,\r\n    })\r\n    return result\r\n  }\r\n  if (dir == ROOT && !e)\r\n    throw new Error(`Package.json for module ${name} not found.`)\r\n  return findPackageJson(join(resolve(dir), '..'), name, opts)\r\n}\r\n\r\n/**\r\n * Finds the path to the entry based on package.json file.\r\n * @param {string} path\r\n * @param {!Array<string>} fields\r\n */\r\nexport const findEntry = async (path, fields = []) => {\r\n  const f = await read(path)\r\n  let mod, version, packageName, main, rest\r\n  try {\r\n    ({\r\n      'module': mod,\r\n      'version': version,\r\n      'name': packageName,\r\n      'main': main,\r\n      ...rest\r\n    } = JSON.parse(f))\r\n    rest = fields.reduce((acc, current) => {\r\n      acc[current] = rest[current]\r\n      return acc\r\n    }, {})\r\n  } catch (err) {\r\n    throw new Error(`Could not parse ${path}.`)\r\n  }\r\n  const dir = dirname(path)\r\n  let resolved = mod || main\r\n  if (!resolved) {\r\n    const indexExists = await exists(join(dir, 'index.js'))\r\n    if (!indexExists) return undefined\r\n    resolved = main = 'index.js'\r\n  }\r\n  let entry = join(dir, resolved)\r\n  let r\r\n  try {\r\n    ({ path: r } = await resolveDep(entry))\r\n    entry = r\r\n  } catch (err) {/* does not exist */}\r\n  return { entry, version, packageName, main: !mod && main,\r\n    entryExists: !!r,\r\n    ...rest }\r\n}\r\n\r\nexport default findPackageJson\r\n\r\n/* documentary types/index.xml */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_fpj.Config} Config The options for `fpj`.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _fpj.Config The options for `fpj`.\r\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` file to return.\r\n * @prop {boolean} [soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_fpj.Return} Return The return type of the program.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _fpj.Return The return type of the program.\r\n * @prop {string} entry The location of the package's entry file. The preference is given to the `module` field.\r\n * @prop {string} packageJson The path to the package.json file itself.\r\n * @prop {string} packageName The name of the resolved package.\r\n * @prop {string} [version] The version of the package.\r\n * @prop {boolean} [hasMain] Whether the entry is the `main` rather than `module`.\r\n * @prop {boolean} [entryExists] In soft mode, will be set to `false` if the entry file does not exist.\r\n */\r\n","import { collect } from 'catchment'\nimport { Replaceable } from 'restream'\nimport { relative, join, dirname, resolve } from 'path'\nimport findPackageJson from 'fpj'\nimport split from '@depack/split'\n\n/**\n * Updates the source code of served JS files to point to the `/node_modules`, e.g., `import 'preact'` -> `import '/node_modules/preact/dist/preact.mjs'`.\n * @param {string} path\n * @param {string} source\n */\nexport const patchSource = async (path, source, { mount, override = {} }) => {\n  const replacement = async (m, pre, from) => {\n    const dir = dirname(path)\n    // ignore local deps which are resolved by middleware\n    if (/^[/.]/.test(from)) {\n      return m\n    }\n    const { name, paths } = split(from)\n    if (override[name]) return `${pre}'${override[name]}'`\n    const {\n      packageJson,\n    } = await findPackageJson(dir, name)\n    const abs = resolve(packageJson)\n    const realFrom = dirname(abs)\n    // explicit dep, e.g., @depack/example/src/index.jsx\n    if (paths) {\n      return getNodeModule(realFrom, paths, pre, mount)\n    }\n    // try module\n    const { module: mod } = require(abs)\n    if (!mod) {\n      console.warn('[\u219b] Package %s does not specify module in package.json, trying src', realFrom)\n      const d = getNodeModule(realFrom, 'src', pre)\n      return d\n    }\n    return getNodeModule(realFrom, mod, pre, mount)\n  }\n  const rs = new Replaceable([\n    {\n      re: /^( *import(?:\\s+[^\\s,]+\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+)['\"](.+)['\"]/gm,\n      replacement,\n    },\n    {\n      re: /^( *import\\s+)['\"](.+)['\"]/gm,\n      replacement,\n    },\n  ])\n  rs.end(source)\n  const body = await collect(rs)\n  return body\n}\n\n\n/**\n * Returns the import statement with the path to the dependency on the file system.\n * @param {string} from File from which module was imported.\n * @param {string} path The import path.\n * @param {string} pre Text before import.\n * @param {string} [mount]\n */\nconst getNodeModule = (from, path, pre, mount) => {\n  const modPath = join(from, path)\n  let modRel = relative('', modPath)\n  if (mount) modRel = relative(mount, modRel)\n  return `${pre}'/${modRel}${modPath.endsWith('/') ? '/' : ''}'`\n}","/**\n * Splits the package name possibly with scope and returns the name and the\n * path within that page that was required.\n * @param {string} from The package, e.g., `@depack/depack/src`, or `depack`.\n */\nconst split = (from) => {\n  let [scope, name, ...paths] = from.split('/')\n  if (!scope.startsWith('@') && name) {\n    paths = [name, ...paths]\n    name = scope\n  } else if (!scope.startsWith('@')) {\n    name = scope\n  } else {\n    name = `${scope}/${name}`\n  }\n  return { name, paths: paths.join('/') }\n}\n\nexport default split","import read from '@wrote/read'\nimport transpileJSX from '@a-la/jsx'\nimport resolveDependency from 'resolve-dependency'\nimport makePromise from 'makepromise'\nimport { lstat, existsSync } from 'fs'\nimport { join, relative } from 'path'\nimport { patchSource } from './lib'\n\n/**\n * @type {!_idio.frontEnd}\n */\nfunction FrontEnd(config = {}) {\n  const {\n    directory = 'frontend',\n    pragma = 'import { h } from \\'preact\\'',\n    mount = '.',\n    override = {},\n  } = config\n  let { log } = config\n  if (log === true) log = console.log\n  const dirs = Array.isArray(directory) ? directory : [directory]\n\n  dirs.forEach((current) => {\n    const dir = join(mount, current)\n    const e = existsSync(dir)\n    if (!e)\n      throw new Error(`Frontend directory ${current} does not exist.`)\n  })\n\n  /**\n   * @type {!_goa.Middleware}\n   */\n  const m = async (ctx, next) => {\n    let p = ctx.path.replace('/', '')\n    const canServe = dirs.includes(p)\n      || dirs.some(d => p.startsWith(`${d}/`))\n      || ctx.path.startsWith('/node_modules/')\n    if (!canServe) {\n      return await next()\n    }\n    p = join(mount, p)\n    const { path, isDir } = await resolveDependency(p)\n    if (isDir && !p.endsWith('/')) {\n      const mountPath = mount ? relative(mount, path) : path\n      ctx.redirect(`/${mountPath}`)\n      return\n    }\n    /** @type {!fs.Stats} */\n    let ls\n    try {\n      ls = /** @type {!fs.Stats} */ (await makePromise(lstat, path))\n    } catch (err) {\n      ctx.status = 404\n      return\n    }\n    ctx.status = 200\n    ctx.etag = `${ls.mtime.getTime()}`\n    if (ctx.fresh) {\n      ctx.status = 304\n      return await next()\n    }\n    let body = await read(path)\n    let start = new Date().getTime()\n    body = await patch(path, body, pragma, { mount, override })\n    let end = new Date().getTime()\n    if (log) /** @type {!Function} */ (log)('%s patched in %sms', path, end - start)\n    ctx.type = 'application/javascript'\n    ctx.body = body\n  }\n  return m\n}\n\nexport default FrontEnd\n\n/**\n * Patches the source code to map node_modules and transpile JSX.\n * @param {string} path Path to the file.\n * @param {string} body The source code to patch.\n * @param {string} pragma Add this import to the body.\n */\nconst patch = async (path, body, pragma, { mount, override }) => {\n  if (/\\.jsx$/.test(path)) {\n    body = transpileJSX(body)\n    if (pragma) body = `${pragma}\\n${body}`\n  }\n  if (/\\.css$/.test(path)) {\n    body = wrapCss(body)\n  } else {\n    body = await patchSource(path, body, { mount, override } )\n  }\n  return body\n}\n\n/**\n * Adds JS wrapper to add CSS dynamically.\n * @param {string} style\n */\nconst wrapCss = (style) => {\n  return `function __$styleInject(css = '') {\n  const head = document.head\n  const style = document.createElement('style')\n  style.type = 'text/css'\n  if (style.styleSheet){\n    style.styleSheet.cssText = css\n  } else {\n    style.appendChild(document.createTextNode(css))\n  }\n  head.appendChild(style)\n}\nconst style = \\`${style}\\`\n__$styleInject(style)`\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').frontEnd} _idio.frontEnd\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('@typedefs/goa').Middleware} _goa.Middleware\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import '@externs/goa'\nimport '../types/externs'\nimport FrontEnd from './'\n\nmodule.exports = FrontEnd"],
"names":["createReadStream","fs","existsSync","lstat","$jscompDefaultExport","stream","Transform","Writable","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","read","path","Script","vm","findPosition","input","h","l2","l","parseInt","c","detectJSX","err","bl","checkRule","reObject","hasRe","type","replacement","hideStack","commonError","thrownError","commonLine","i","substr","li","lastIndexOf","SyncReplaceable","rules","fr","reduce","s","acc","_broke","Acc","t","call","p","brake","replace.brake","getDefaultRegExp","name","toUpperCase","getDefaultReplacement","index","makeMarkers","matchers","config","keys","key","getReplacement","getRegex","regExp","lastIndex","marker","makePasteRule","pipeRules","rule","Array","isArray","pr","makeCutRule","replaceable","Replaceable","_options","context","Replaceable$$module$node_modules$restream$src$Replaceable.replace","forEach","string","promises","resolve","data","all","shift","next","Stream","end","getTagName","tagName","exec","getProps","props","positions","current","closing","opening","open","close","obj","destructuring","whitespace","lastClose","before","wsBefore","propName","wsBeforeAssign","afterAssign","val","beforeAssign","beforeOrNot","bb","plain","ws","getPlain","whatsLeft","wsAfterAssign","q","repeat","Boolean","makeObjectBody","pp","quoteProps","beforeCloseWs","a","k","v","kk","isComponentName","pragma","children","warn","cn","tn","qp","cc","prev","comma","findEnding","contentEnd","preString","extract","stringWithTag","arrow","content","selfClosing","ExtractedJSX","contentStart","stringEnd","opensClosing","endsWith","untilEnd","ce","tSelfClosing","string2","getQuoted","_b","_a","b","rr","parseSimpleContent","temps","expressionStack","jsxStack","isExpression","to","expression","extractedJsx","getTemps","lastTo","ar","transpileJSX","position","parseContent","f","after","ld","newRes","contents","jsx","part","strBefore","strAfter","defObj","ef","ias","ii","tt","as","makePromise","fn","resolveValue","fnLength","reject","error","allArgs","exists","ls","dirname","parse","relative","resolveDependency","isDir","checkSources","isDirectory","fileChecked","fileRes","startsWith","ROOT","findPackageJson","dir","process","cwd","fields","soft","fold","findEntry","entryExists","main","entry","version","packageName","rest","result","packageJson","hasMain","mod","JSON","resolved","indexExists","patchSource","mount","override","pre","scope","paths","abs","realFrom","getNodeModule","require","console","body","modPath","modRel","patch","module","exports","FrontEnd","directory","log","dirs","ctx","some","mountPath","redirect","status","etag","mtime","getTime","fresh","start","Date"]
}
