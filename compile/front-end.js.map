{
"version":3,
"file":"compile/front-end.js",
"lineCount":49,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/vm/index.js","node_modules/@a-la/detect-jsx/src/lib/index.js","node_modules/@a-la/detect-jsx/src/index.js","node_modules/restream/src/lib/index.js","node_modules/restream/src/SyncReplaceable.js","node_modules/restream/src/lib/markers.js","node_modules/restream/src/Replaceable.js","node_modules/@a-la/jsx/src/lib/index.js","node_modules/@a-la/jsx/src/lib/extract.js","node_modules/@a-la/jsx/src/lib/parse-content.js","node_modules/@a-la/jsx/src/lib/components.js","node_modules/@a-la/jsx/src/index.js","node_modules/makepromise/src/index.js","node_modules/@wrote/exists/src/index.js","node_modules/path/index.js","node_modules/resolve-dependency/src/index.js","node_modules/mismatch/src/index.js","node_modules/erte/src/index.js","node_modules/crypto/index.js","node_modules/@idio/websocket/src/lib.js","node_modules/@idio/websocket/src/index.js","node_modules/fpj/src/index.js","src/lib/index.js","node_modules/@depack/split/src/index.js","src/inject-css.js","src/lib/hr.js","src/index.js","src/depack.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","export default vm\nexport const {\n  Script,\n  createContext,\n  isContext,\n  runInContext,\n  runInDebugContext,\n  runInNewContext,\n  runInThisContext,\n} = vm","/**\n * The function to extract the position of the symbol from the error due to the fact that the script body couldn't be evaluated by the _vm.Script_ constructor.\n * @param {string} stack The error stack.\n * @param {string} input The input which was passed to the evaluation.\n */\nexport const findPosition = (stack, input) => {\n  const [h, , l2] = stack.split('\\n')\n  const l = parseInt(h.replace(/.+?(\\d+)$/, (m, d) => d)) - 1\n  const c = l2.indexOf('^')\n  const { length } = input.split('\\n').slice(0, l).join('\\n')\n  const lb = length + c + (l ? 1 : 0)\n  return lb\n}","import { Script } from 'vm'\nimport { findPosition } from './lib'\n\n/**\n * Returns the index of the opening `<` symbol in a JSX tag by calling a Script constructor and extracting information from the error message.\n * @param {string} input The string to evaluate in the V8 VM as JavaScript with JSX. If there is no `<`, the `null` is returned. Any another error in code will be thrown as is.\n */\nconst detectJSX = (input) => {\n  try {\n    new Script(input)\n  } catch (err) {\n    const { message, stack } = err\n    if (!/Unexpected token '?</.test(message)) throw err\n    const bl = findPosition(stack, input)\n    return bl\n  }\n  return null\n}\n\nexport default detectJSX\n\n/* documentary types/index.xml */\n/**\n * @typedef {Object} Config Options for the program.\n * @prop {boolean} [shouldRun=true] A boolean option. Default `true`.\n * @prop {string} text A text to return.\n */\n","export function checkRule(reObject) {\n  if (typeof reObject != 'object') {\n    return false\n  }\n  const { re, replacement } = reObject\n  const hasRe = re instanceof RegExp\n  const type = ['string', 'function'].indexOf(typeof replacement) != -1\n  return hasRe && type\n}\n\nexport const hideStack = (commonError, thrownError) => {\n  if (!(thrownError instanceof Error)) throw thrownError\n  const [, , commonLine] = commonError.stack.split('\\n', 3)\n  const i = thrownError.stack.indexOf(commonLine)\n  if (i == -1) throw thrownError\n  const stack = thrownError.stack.substr(0, i - 1)\n  const li = stack.lastIndexOf('\\n')\n  thrownError.stack = stack.substr(0, li)\n  throw thrownError\n}","import { checkRule, hideStack } from './lib'\n\n/**\n  * _SyncReplaceable_ function receives the whole string and returns the result of transform rules which are either sync function replacers or string replacements (see https://github.com/artdecocode/restream#rule-type for more info). This is not a class and just a function.\n  * @param {string|!Buffer} input The string or buffer to transform synchronously using the replacements. Does not support asynchronous replacements.\n  * @param {!Array<!_restream.Rule>} rules An array with rules.\n  * @return {string}\n  * @example\n```\n// markdown __ to html <em> implementation\nconst stream = SyncReplaceable('__hello world__', {\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n  */\nfunction SyncReplaceable(input, rules) {\n  /**\n   * @suppress {globalThis}\n   */\n  function replace() {\n    const fr = rules.filter(checkRule)\n    const s = fr.reduce((acc, { re, replacement }) => {\n      /** @type {string} */\n      let Acc = acc\n      if (this._broke) return Acc\n\n      if (typeof replacement == 'string') {\n        Acc = Acc.replace(re, replacement)\n        return Acc\n      } else {\n        let commonError\n        const t = Acc.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) return match\n            const p = replacement.call(this, match, ...args)\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        return t\n      }\n    }, `${input}`)\n    return s\n  }\n  replace.brake = () => { replace._broke = true }\n  return replace.call(replace)\n}\n\nexport default SyncReplaceable\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */","import SyncReplaceable from '../SyncReplaceable'\n\n/**\n * @param {string} name\n */\nconst getDefaultRegExp = (name) => {\n  return new RegExp(`%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%`, 'g')\n}\n\n/**\n * Make a unique string to replace cut text with.\n * @param {string} name\n * @param {number} index\n */\nconst getDefaultReplacement = (name, index) => {\n  return `%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%`\n}\n\n/**\n * Create a new marker.\n * @param {string} name The name of the matcher, used in the doc marker.\n * @param {!RegExp} re The regular expression used for detection.\n * @param {!_restream.MakeMarkersConfig} [conf] Additional configuration.\n * @param {function(string, number): string} [conf.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [conf.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @return {!_restream.Marker} The marker.\n */\nconst makeMarker = (name, re, conf) => {\n  const {\n    getReplacement = getDefaultReplacement,\n    getRegex = getDefaultRegExp,\n  } = conf || {}\n  const regExp = getRegex(name)\n  return {\n    name,\n    re,\n    regExp,\n    getReplacement,\n    map: {},\n    lastIndex: 0,\n  }\n}\n\n/**\n * Make markers from a configuration object.\n * @param {!Object.<string, !RegExp>} matchers An object with types of markers to create as keys and their detection regexes as values.\n * @param {!_restream.MakeMarkersConfig} [config] Additional configuration.\n * @param {function(string, number): string} [config.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [config.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @returns {!Object.<string, !_restream.Marker>} An object with markers for each requested type.\n */\nexport const makeMarkers = (matchers, config) => {\n  const res = Object.keys(matchers).reduce((acc, key) => {\n    const re = matchers[key]\n    const marker = makeMarker(key, re, config)\n    const m = {\n      ...acc,\n      [key]: marker,\n    }\n    return m\n  }, {})\n  return res\n}\n\n/**\n * Make a rule for pasting markers back.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @param {!(_restream.Rule|Array<!_restream.Rule>)} [pipeRules] Any additional rules to replace the value of the marker before pasting it.\n * @returns {!_restream.Rule} A rule to paste previously replaced chunks.\n */\nexport const makePasteRule = (marker, pipeRules = []) => {\n  const { regExp: re, map } = marker\n  const rule = {\n    re,\n    replacement(match, index) {\n      const m = map[index]\n      delete map[index]\n      const pr = Array.isArray(pipeRules) ? pipeRules : [pipeRules]\n      const res = SyncReplaceable(m, pr)\n      return res\n    },\n  }\n  return rule\n}\n\n/**\n * Make a rule for initial replacement of markers.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @returns {!_restream.Rule} A rule to cut matched chunks.\n */\nexport const makeCutRule = (marker) => {\n  const { re, map, getReplacement, name } = marker\n  const rule = {\n    re,\n    replacement(match) {\n      const { lastIndex } = marker\n      map[lastIndex] = match\n      marker.lastIndex += 1\n      const m = getReplacement(name, lastIndex)\n      return m\n    },\n  }\n  return rule\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */\n\n/* documentary types/markers.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.Marker} Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @prop {string} name The name of the marker for annotation purposes.\n * @prop {function(string, number): string} getReplacement The function to generate marker placeholders which can be then found, e.g., for (name: `marker`, index: `10`) by default _Restream_ will generate `%%_RESTREAM_MARKER_REPLACEMENT_10_%%`, but can be overriden with this method.\n * @prop {!RegExp} re The regular expression used for detection of the match.\n * @prop {!RegExp} regExp The generated regular expression to replace the marker back to its original value.\n * @prop {!Object<number, string>} map The map which holds detected matches at their indexes.\n * @prop {number} lastIndex The index of the last inserted element. Starts with 0.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.MakeMarkersConfig} MakeMarkersConfig Additional configuration.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.MakeMarkersConfig Additional configuration.\n * @prop {function(string, number): string} [getReplacement] The function used to create a replacement when some text needs to be cut.\n * @prop {function(string): !RegExp} [getRegex] The function used to create a RegExp to detect replaced chunks.\n */\n","import Stream, { Transform } from 'stream'\nimport cleanStack from '@artdeco/clean-stack'\nimport { collect } from 'catchment'\nimport { checkRule, hideStack } from './lib'\n\nexport default class Replaceable extends Transform {\n  /**\n   * Replaceable class that extends Transform and pushes data when it's done replacing each incoming chunk. If the replacement is passed as a function, it will work in the same way as the replacer for `string.replace` method (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace), taking the `match` as the first argument, and matched `p1`, `p2`, _etc_ parameters as following arguments. The replacer can also be an async function.\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules A single replacement rule, or multiple rules.\n   * @param {!stream.TransformOptions} [options] The options for the transform stream.\n   * @example\n   *\n```\n// markdown __ to html <em> implementation\nconst stream = replaceStream({\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n   */\n  constructor(rules, options) {\n    super(options)\n    const re = Array.isArray(rules) ? rules : [rules]\n    const fr = re.filter(checkRule)\n    this.rules = fr\n    /**\n     * Whether the _Replaceable_ will not apply any more rules.\n     * @type {boolean}\n     */\n    this._broke = false\n    this._options = options\n  }\n\n  /**\n   * Creates a new replaceable to replace the given string, buffer or stream using the rules of the current stream. Calling `brake` will also set `_broke` on the parent stream.\n   * @param {string|!Buffer|!Stream} input The input to replace.\n   * @param {!Object} [context] The context to assign to the new replaceable.\n   */\n  async replace(input, context) {\n    const replaceable = new Replaceable(this.rules, this._options)\n    if (context) Object.assign(replaceable, context)\n    const res = await Replaceable.replace(replaceable, input)\n    if (replaceable._broke) this.brake()\n    if (context) Object.keys(context).forEach(key => {\n      context[key] = replaceable[key]\n    })\n    return res\n  }\n  /**\n   * The method to end the stream with given data, and collect the result.\n   * @param {!Replaceable} replaceable\n   * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n   */\n  static async replace(replaceable, input) {\n    return replace(replaceable, input)\n  }\n\n  /**\n   * Stop executing further after the current rule.\n   */\n  brake() {\n    this._broke = true\n  }\n\n  /**\n   * @param {string|!Buffer} chunk The incoming chunk, or an object if the stream was started in object mode.\n   */\n  async reduce(chunk) {\n    /** @type {string} */\n    const s = await this.rules.reduce(async (acc, { re, replacement }) => {\n      /** @type {string} */\n      let string = await acc\n      if (this._broke) return string\n\n      if (typeof replacement == 'string') {\n        string = string.replace(re, replacement)\n      } else {\n        const promises = []\n        let commonError\n        const t = string.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) {\n              if (promises.length)\n                return promises.push(Promise.resolve(match))\n              return match\n            }\n            const p = replacement.call(this, match, ...args)\n            if (p instanceof Promise) {\n              promises.push(p)\n            }\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        if (promises.length) {\n          try { // hide stack only for when throw happens before awaits\n            const data = await Promise.all(promises)\n            string = string.replace(re, () => data.shift())\n          } catch (e) {\n            hideStack(commonError, e)\n          }\n        } else {\n          string = t\n        }\n      }\n      return string\n    }, `${chunk}`)\n\n    return s\n  }\n  /**\n   * @suppress {checkTypes}\n   * @returns {!Promise}\n   */\n  async _transform(chunk, _, next) {\n    try {\n      const s = await this.reduce(chunk)\n      this.push(s)\n      next()\n    } catch (e) {\n      const s = cleanStack(e.stack)\n      e.stack = s\n      next(e)\n    }\n  }\n}\n\n/**\n * The method to end the stream with given data, and collect the result.\n * @param {!Replaceable} replaceable\n * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n */\nexport async function replace(replaceable, input) {\n  if (input instanceof Stream) {\n    input.pipe(replaceable)\n  } else {\n    replaceable.end(input)\n  }\n  /** @type {string} */\n  const data = await collect(replaceable)\n  return data\n}\n\n/**\n * The class for when serial execution of asynchronous replacements withing the same rule are needed.\n */\nexport class SerialAsyncReplaceable extends Replaceable {\n  /**\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules\n   */\n  constructor(rules) {\n    super(rules)\n    this.promise = Promise.resolve()\n  }\n  addItem(fn) {\n    const pp = this.promise.then(fn)\n    this.promise = pp\n    return pp\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Rule} _restream.Rule\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').AsyncReplacer} _restream.AsyncReplacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Replacer} _restream.Replacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').TransformOptions} stream.TransformOptions\n */","import { SyncReplaceable } from 'restream'\n\n/**\n * Returns the name of the opening tag from the string starting with <, or `undefined`.\n * @param {string} string The string where to find the tag.\n * @example\n * const s = '<div>hello world</div>'\n * const tag = getTagName(s) // div\n */\nexport const getTagName = (string) => {\n  const [, tagName] = /<\\s*(.+?)(?:\\s+[\\s\\S]+)?\\s*\\/?\\s*>/.exec(string) || []\n  return tagName\n}\n\n// * const getClass = o => Object.keys(o).join(' ')\n\n/**\n * Parses a string with attributes written in jsx, e.g., `id={id}` into an object.\n * @param {string} props The string with properties in the tag\n * @example\n *\n * const El = getProps(\"class={'hello world'} id={id}\")\n * // =>\n   {\n     class: \"'hello world'\",\n     id: 'id'\n    }\n *\n */\nexport const getProps = (props, {\n  withClass = false,\n  classNames = [],\n  renameMap = {},\n} = {}) => {\n  let stack = 0\n  const positions = []\n  let current\n  SyncReplaceable(props, [\n    {\n      re: /[{}]/g,\n      replacement(m, i) {\n        const closing = m == '}'\n        const opening = !closing\n        if (!stack && closing)\n          throw new Error('A closing } is found without opening one.')\n        stack += opening ? 1 : -1\n        if (stack == 1 && opening) {\n          current = {\n            open: i,\n          }\n        } else if (stack == 0 && closing) {\n          current.close = i\n          positions.push(current)\n          current = {}\n        }\n      },\n    },\n  ])\n  if (stack) throw new Error(`Unbalanced props (level ${stack}) ${props}`)\n  const obj = {}\n  const destructuring = []\n  const whitespace = {}\n  const lastClose = positions.reduce((acc, { open, close }) => {\n    const before = props.slice(acc, open)\n    const [, wsBefore, propName, wsBeforeAssign, afterAssign] = /(\\s*)(\\S+)(\\s*)=(\\s*)$/.exec(before) || []\n    const val = props.slice(open + 1, close)\n    if (!propName && !/\\s*\\.\\.\\./.test(val))\n      throw new Error('Could not detect prop name')\n    if (!propName) {\n      destructuring.push(val)\n    } else {\n      obj[propName] = val\n    }\n    whitespace[propName] = { before: wsBefore, beforeAssign: wsBeforeAssign, afterAssign }\n    const beforeOrNot = before || '' // when using destructuring\n    const propOrNot = propName || ''\n    const bb = beforeOrNot.slice(0, beforeOrNot.length - propOrNot.length - 1)\n    const { plain, whitespace: ws } = getPlain(bb)\n    Object.assign(obj, plain)\n    Object.assign(whitespace, ws)\n    return close + 1\n  }, 0)\n  // make sure plain attrs are there when no {} are given\n  if (!positions.length) {\n    const { plain, whitespace: ws } = getPlain(props)\n    Object.assign(obj, plain)\n    Object.assign(whitespace, ws)\n  } else {\n    const whatsLeft = props.slice(lastClose)\n    const { plain, whitespace: ws } = getPlain(whatsLeft)\n    Object.assign(obj, plain)\n    Object.assign(whitespace, ws)\n  }\n  let ro = obj\n  if (withClass || (Array.isArray(classNames) && classNames.length)\n    || Object.keys(classNames).length) {\n    ({ ...ro } = obj)\n    const cl = []\n    Object.keys(ro).forEach((k) => {\n      const p = () => {\n        cl.push(k)\n        delete ro[k]\n      }\n      if (Array.isArray(classNames) && classNames.includes(k)) p()\n      else if (classNames[k]) p()\n      else if (withClass) {\n        const l = k[0]\n        if (l.toUpperCase() == l) p()\n      }\n    })\n\n    if (cl.length) {\n      const className = cl.map((cn) => {\n        const r = cn in renameMap ? renameMap[cn] : cn\n        return r\n      }).join(' ')\n      if (ro.className) {\n        if (/[`\"']$/.test(ro.className)) {\n          ro.className = ro.className.replace(/([`\"'])$/, ` ${className}$1`)\n        } else\n          ro.className += `+' ${className}'`\n      } else if (ro.class) {\n        if (/[`\"']$/.test(ro.class)) {\n          ro.class = ro.class.replace(/([`\"'])$/, ` ${className}$1`)\n        } else\n          ro.class += `+' ${className}'`\n      } else {\n        ro.className = `'${className}'`\n      }\n    }\n  }\n  return { obj: ro, destructuring, whitespace }\n}\n\n/**\n * Returns the matches without {}, such as `id=\"test\"`.\n * @param {string} string The string with plain attributes.\n */\nconst getPlain = (string) => {\n  const r = []\n  const whitespace = {}\n  const res = string.replace(/(\\s*)(\\S+)(\\s*)=(\\s*)([\"'])([\\s\\S]*?)\\5/g, (m, wsBefore, name, wsBeforeAssign, wsAfterAssign, q, val, i) => {\n    whitespace[name] = { before: wsBefore, beforeAssign: wsBeforeAssign, afterAssign: wsAfterAssign }\n    r.push({ i, name, val: `${q}${val}${q}` })\n    return '%'.repeat(m.length)\n  })\n  res.replace(/(\\s*)([^\\s%]+)/g, (m, ws, name, i) => {\n    whitespace[name] = { before: ws }\n    r.push({ i, name, val: 'true' }) // boolean\n  })\n  const obj = [...r.reduce((acc, { i, name, val }) => {\n    acc[i] = [name, val]\n    return acc\n  }, [])].filter(Boolean).reduce((acc, [name, val]) => {\n    acc[name] = val\n    return acc\n  }, {})\n  return { plain: obj, whitespace }\n}\n\n/**\n * Accepts the parsed node properties to make a JS object string out of them.\n * @param {!Object<string, string>} pp The properties out of which to make a string object.\n * @returns {string|null} Either a JS object body string, or null if no keys were in the object.\n */\nexport\nconst makeObjectBody = (pp, destructuring = [], quoteProps = false, whitespace = {}, beforeCloseWs = '') => {\n  const keys = Object.keys(pp)\n  const { length } = keys\n  if (!length && !destructuring.length) return '{}'\n  const pr = `{${keys.reduce((a, k) => {\n    const v = pp[k]\n    const kk = quoteProps || k.indexOf('-') != -1 ? `'${k}'` : k\n    const { before = '', beforeAssign = '', afterAssign = '' } = whitespace[k] || {}\n    return [...a, `${before}${kk}${beforeAssign}:${afterAssign}${v}`]\n  }, destructuring).join(',')}${beforeCloseWs}}`\n  return pr\n}\n\nexport const isComponentName = (tagName = '') => {\n  const [t] = tagName\n  if (!t) throw new Error('No tag name is given')\n  return t.toUpperCase() == t\n}\n\n/**\n * Creates a string invocation of the pragma function.\n * @param {string} tagName The name of the tag to create, or a reference to a component function.\n * @param {!Object<string, string>} props The properties of the element. The properties' values can be passed as strings or references as the `e` function will be called under the scope in which the JSX is written, e.g., when creating components `const C = ({ reference }) => <div id={reference} class=\"String\"/>`.\n * @param {!Array<string>} children The array with the child nodes which are strings, but encode either a reference, a string or an invocation the the `e` function again. Thus the jsx is parsed recursively depth-first.\n * @param {!Array<string>} [destructuring] Any properties for destructuring.\n * @param {boolean|string} [quoteProps=false] Whether to quote the properties' keys (for Closure compiler).\n * @example\n *\n * const r = pragma('div', { id: \"'STATIC_ID'\" }, [\"'Hello, '\", \"test\", \"'!'\"])\n * // =>\n * e('div',{ id: 'STATIC_ID' },['Hello, ', test, '!'])\n */\nexport const pragma = (tagName, props = {}, children = [], destructuring = [], quoteProps = false, warn = null, whitespace = {}, beforeCloseWs = '') => {\n  const cn = isComponentName(tagName)\n  const tn = cn ? tagName : `'${tagName}'`\n  if (!Object.keys(props).length && !children.length && !destructuring.length) {\n    return `h(${tn})`\n  }\n  const qp = cn && quoteProps == 'dom' ? false : quoteProps\n  if (!cn && destructuring.length && (!quoteProps || quoteProps == 'dom')) {\n    warn && warn(`JSX: destructuring ${destructuring.join(' ')} is used without quoted props on HTML ${tagName}.`)\n  }\n  const pr = makeObjectBody(props, destructuring, qp, whitespace, beforeCloseWs)\n  const c = children.reduce((acc, cc, i) => {\n    const prev = children[i-1]\n    let comma = ''\n    if (prev && /^\\/\\*[\\s\\S]*\\*\\/$/.test(prev)) comma = ''\n    else if (prev && /\\S/.test(prev)) comma = ','\n    return `${acc}${comma}${cc}`\n  }, '')\n  const res = `h(${tn},${pr}${c ? `,${c}` : ''})`\n  return res\n}\n\n// export const newPragma = (tagName, ...args) => {\n//   return `e('${tagName}',${args.join(',')})`\n// }\n\n// * @todo In strict mode, when the length is more, throws an error. In advanced mode, the replacement should be aligned so it is possible to debug it.\n\n/**\n * Replaces a piece of string inside of a string with another chunk.\n * @param {string} input The string inside of which the chunk needs to be replaced.\n * @param {number} index The index of the `<` found with `detect-jsx.findPosition`.\n * @param {number} length The length of the string that needs to be cut out.\n * @param {string} chunk The new string that needs to be placed back into the input.\n *\n */\nexport\nconst replaceChunk = (input, index, length, chunk) => {\n  const before = input.slice(0, index)\n  const after = input.slice(index + length)\n  const ld = length - chunk.length\n  // if (ld < 0)\n  // console.warn('The chunks length is more that replaced input')\n  // throw new Error('The length of the chunk cannot be more than of the replaced value.')\n  let p = chunk\n  if (ld > 0) {\n    p = `${' '.repeat(ld)}${p}`\n  }\n  const res = `${before}${p}${after}`\n  return res\n}","import { SyncReplaceable, makeMarkers, makeCutRule } from 'restream'\nimport { getTagName } from './'\n\nconst findEnding = (string, rules = []) => {\n  let stack = 0\n  let contentEnd\n  const preString = SyncReplaceable(string, [\n    ...rules,\n    {\n      // once the tag is opened with <, its closing symbol > will always be even (nevermind comments & strings)\n      re: /[<>]/g,\n      replacement(m, i) {\n        if (contentEnd) return m\n        const opening = m == '<'\n        const closing = !opening\n        stack += opening ? 1 : -1\n        if (stack == 0 && closing) {\n          contentEnd = i\n        }\n        return m\n      },\n    },\n  ])\n  if (stack) throw new Error(1)\n  return { preString, contentEnd }\n}\n\n/**\n * Returns the outer body of the tag.\n * @param {string} stringWithTag The string in which to find the closing tag. Must start with a `<`.\n */\nconst extract = (stringWithTag) => {\n  const tagName = getTagName(stringWithTag)\n  let contentEnd\n  let props\n  const { arrow } = makeMarkers({\n    arrow: /=>/g,\n  })\n  let preString\n  try {\n    ({ preString, contentEnd } = findEnding(stringWithTag, [ makeCutRule(arrow) ]))\n  } catch (err) {\n    if (err === 1) throw new Error(`Could not find the matching closing > for ${tagName}.`)\n  }\n\n  const string = preString.slice(0, contentEnd + 1)\n  let content = string\n    .replace(/<\\s*[^\\s/>]+/, '')\n  const selfClosing = /\\/\\s*>$/.test(content)\n  if (selfClosing) {\n    props = content.replace(/\\/\\s*>$/, '')\n    content = ''\n    return new ExtractedJSX({\n      string: string.replace(arrow.regExp, '=>'),\n      props: props.replace(arrow.regExp, '=>'),\n      content: '',\n      tagName,\n    })\n  }\n  // now find the corresponding closing tag\n  props = content.replace(/>$/, '')\n  const contentStart = contentEnd + 1\n  contentEnd = false\n  let stack = 1\n  let stringEnd\n  SyncReplaceable(preString, [{\n    // [\\\\s\\\\S] is to not catch the very beginning\n    re: new RegExp(`[\\\\s\\\\S](?:<\\\\s*${tagName}(\\\\s+|>)|/\\\\s*${tagName}\\\\s*>)`, 'g'),\n    replacement(m, opensClosing, i, s) {\n      if (contentEnd) return m\n      const closing = !opensClosing && m.endsWith('>')\n      const opening = !closing\n\n      if (opening) {\n        const untilEnd = s.slice(i)\n        const { contentEnd: ce } = findEnding(untilEnd\n          .replace(/^[\\s\\S]/, ' ')\n          // e.g., <span><a /><span></span></span>\n          //                 ^\n        )\n        const t = untilEnd.slice(0, ce + 1)\n        const tSelfClosing = /\\/\\s*>$/.test(t)\n        if (tSelfClosing) return m\n      }\n\n      stack += opening ? 1 : -1\n      if (stack == 0 && closing) {\n        contentEnd = i\n        stringEnd = contentEnd + m.length\n      }\n      return m\n    },\n  }])\n  if (stack) throw new Error(`Could not find the matching closing </${tagName}>.`)\n  content = preString.slice(contentStart, contentEnd)\n  const string2 = preString.slice(0, stringEnd)\n    .replace(arrow.regExp, '=>')\n\n  return new ExtractedJSX({\n    string: string2,\n    props: props.replace(arrow.regExp, '=>'),\n    content: content.replace(arrow.regExp, '=>'),\n    tagName,\n  })\n}\n\nexport class ExtractedJSX {\n  /**\n   * @param {{ string: string, props: string, content: string, tagName: string }} properties\n   */\n  constructor(properties) {\n    this.string = properties.string\n    this.props = properties.props\n    this.content = properties.content\n    this.tagName = properties.tagName\n  }\n}\n\nexport default extract","import { SyncReplaceable } from 'restream'\nimport extract from './extract'\n\n/**\n * Make a quoted string to interpret by JS.\n * @param {string} s\n * @example\n *\n * getQuoted('The mind always seeks to equilibrium.')\n * // result:\n * `The mind always seeks to equilibrium.`\n */\nexport const getQuoted = (s) => {\n  let _b = '', _a = ''\n  const r = s\n    .replace(/^(\\r?\\n\\s*)([\\s\\S]+)?/, (m, b, v = '') => {\n      _b = b\n      return v\n    })\n    .replace(/([\\s\\S]+?)?(\\r?\\n\\s*)$/, (m, v = '', a = '') => {\n      _a = a\n      return v\n    })\n  const rr = r ? `\\`${r}\\`` : ''\n  return `${_b}${rr}${_a}`\n}\n\n/**\n * Returns the array of children for an element by extracting the parts in `{}`.\n * @param {string} string\n * @example\n * parseSimpleContent('Hello, {test}!')\n * // result:\n * [`Hello, `, test, `!`]\n */\nexport const parseSimpleContent = (string) => {\n  const temps = []\n  // let prev = 0\n  let current = {}\n  let expressionStack = 0\n  let jsxStack = 0\n  SyncReplaceable(string, [{\n    re: /[<{}]/g,\n    replacement(m, i) {\n      if (i < jsxStack) return // blocked by jsx\n      const isExpression = /[{}]/.test(m)\n      let opening\n      if (isExpression) {\n        opening = m == '{'\n        expressionStack += opening ? 1 : -1\n        if (expressionStack == 1 && current.from == undefined) current.from = i\n        else if (expressionStack == 0) {\n          current.to = i + 1\n          current.expression = string.slice(current.from + 1, i)\n          temps.push(current)\n          current = {}\n        }\n      } else {\n        if (expressionStack) return m\n        const extractedJsx = extract(string.slice(i))\n        jsxStack = i + extractedJsx.string.length\n        current.extractedJsx = extractedJsx\n        current.to = jsxStack\n        current.from = i\n        temps.push(current)\n        current = {}\n      }\n    },\n  }, {\n  }])\n  const res = temps.length ? getTemps(string, temps) : [getQuoted(string)]\n  return res\n}\n\n/**\n * Returns the array with broken down string parts either as other strings or expressions.\n * @param {string} string The initial string.\n * @param {Array<!{from: number, to: number, expression: string }>} temps\n * @return {!Array<string>}\n * @private This is called by parseSimpleContent.\n */\nconst getTemps = (string, temps) => {\n  let lastTo = 0\n  const ar = temps.reduce((acc, { from, to, expression, extractedJsx }) => {\n    const b = string.slice(lastTo, from)\n    if (b) acc.push(getQuoted(b))\n    lastTo = to\n    if (expression) acc.push(expression)\n    else if (extractedJsx) acc.push(extractedJsx)\n    return acc\n  }, [])\n  if (lastTo < string.length) {\n    const a = string.slice(lastTo, string.length)\n    // .trim()\n    if (a) ar.push(getQuoted(a))\n  }\n  return ar\n}","import detectJSX from '@a-la/detect-jsx'\nimport { parseSimpleContent } from './parse-content'\nimport { pragma, replaceChunk, getProps } from './'\nimport extract, { ExtractedJSX } from './extract'\n\n\n/* <div id={'id'}>\n  Hello, {test}! {children}\n  <div class={'TEST'} id={id}>test</div>\n</div> */\n\n/**\n * The entry point to transpiling a file.\n * @param {string} input The string to transpile.\n * @param {_alaJsx.Config} config Transpilation config.\n * @returns {string} The transpiled source code with `h` pragma for hyperscript invocations.\n */\nconst transpileJSX = (input, config = {}) => {\n  const { quoteProps, warn, prop2class, classNames, renameMap } = config\n  const position = detectJSX(input)\n  if (position === null) return input\n\n  const s = input.slice(position)\n  const { props = '', content, tagName, string: { length } } = extract(s)\n  const children = parseContent(content, quoteProps, warn, config)\n  const { obj, destructuring, whitespace } = getProps(props.replace(/^ */, ''), {\n    withClass: prop2class,\n    classNames,\n    renameMap,\n  })\n  const beforeCloseWs = /\\s*$/.exec(props) || ['']\n  const f = pragma(tagName, obj, children, destructuring, quoteProps, warn, whitespace, beforeCloseWs)\n  const res = replaceChunk(input, position, length, f)\n  // find another one one\n  const newRes = transpileJSX(res, config)\n  return newRes\n}\n\nexport default transpileJSX\n\n// let f\n// if (props) {\n//   f = pragma(tagName, prop, children) // `p(tag, { ...props }, children)`\n// } else if (children.length == 1) {\n//   f = pragma(tagName, children[0]) // `e(tag, child)`\n// } else if (children.length) {\n//   f = newPragma(tagName, ...children) // `e(tag, child, child2)`\n// }\n\n// parse the content bro parse it\n/**\n * This function will return an array with content of a jsx tag, and the content can be a function to create an element (pragma), a string, or an expression.\n * @param {string} content\n * @param {boolean|string} [quoteProps=false] Whether to quote properties.\n * @param {Function} warn\n * @param {_alaJsx.Config} config\n */\nexport const parseContent = (content, quoteProps = false, warn = null,\n  config = {}) => {\n  if (!content) return []\n  // const C = content\n  // .split('\\n').filter(a => !/^\\s*$/.test(a)).join('\\n')\n  const contents = parseSimpleContent(content) // split by expressions\n  const jsx = contents.reduce((acc, string) => {\n    if (string instanceof ExtractedJSX) {\n      const { props = '', content: part, tagName } = string\n      const { obj, destructuring } = getProps(props, {\n        withClass: config.prop2class,\n        classNames: config.classNames,\n        renameMap: config.renameMap,\n      })\n      const children = parseContent(part, quoteProps, warn, config)\n      const p = pragma(tagName, obj, children, destructuring, quoteProps, warn)\n      return [...acc, p]\n    }\n    const j = detectJSX(string)\n    if (j) {\n      const s = string.slice(j)\n      const { string: { length }, props = '', content: part, tagName } = extract(s)\n      const { obj, destructuring } = getProps(props, {\n        withClass: config.prop2class,\n        classNames: config.classNames,\n        renameMap: config.renameMap,\n      })\n      const children = parseContent(part, quoteProps, warn, config)\n      const p = pragma(tagName, obj, children, destructuring, quoteProps, warn)\n      const strBefore = string.slice(0, j)\n      const strAfter = string.slice(j + length)\n      return [...acc, `${strBefore}${p}${strAfter}`]\n    }\n    return [...acc, string]\n  }, [])\n  return jsx\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Config} _alaJsx.Config\n */","import transpileJSX from './lib/components'\nimport { SyncReplaceable,\n  makeMarkers, makeCutRule, makePasteRule } from 'restream'\n\n/**\n * Process a JSX file.\n * @param {string} input The source code with JSX to transpile.\n * @param {!_alaJsx.Config} config Options for the program.\n * @param {(boolean|string)} [config.quoteProps=false] Whether to surround property names with quotes. When the `dom` string is passed, it will only quote props for invoking html components, i.e., those that start with a lowercase letter (E.g., for the _Google Closure Compiler_). Default `false`.\n * @param {function(...string)} [config.warn] The function to receive warnings, e.g., when destructuring of properties is used on dom elements (for Closure Compiler).\n * @param {boolean} [config.prop2class=false] If a property name starts with a capital letter, the `className` of the _VNode_ will be updated. Default `false`.\n * @param {!Array<string>|!Object} [config.classNames] The list of properties to put into the `className` property.\n * @param {!Object<string, string>} [config.renameMap] How to rename classes (only applies to `prop2class` and `classNames`).\n */\nconst jsx = (input, config = {}) => {\n  const { e, defObj, ef, i, ias, ii } = makeMarkers({\n    defObj: /^ *export\\s+default\\s+{[\\s\\S]+?}/mg,\n    e: /^ *export\\s+(?:default\\s+)?/mg,\n    ef: /^ *export\\s+{[^}]+}\\s+from\\s+(['\"])(?:.+?)\\1/mg,\n    i: /^ *import(\\s+([^\\s,]+)\\s*,?)?(\\s*{(?:[^}]+)})?\\s+from\\s+['\"].+['\"]/gm,\n    ias: /^ *import\\s+(?:(.+?)\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+['\"].+['\"]/gm,\n    ii: /^ *import\\s+['\"].+['\"]/gm,\n  }, {\n    getReplacement(name, index) {\n      return `/*%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%*/`\n    },\n    getRegex(name) {\n      return new RegExp(`/\\\\*%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%\\\\*/`, 'g')\n    },\n  })\n  const s = SyncReplaceable(input, [\n    makeCutRule(ef), makeCutRule(defObj), makeCutRule(e),\n    makeCutRule(i), makeCutRule(ias), makeCutRule(ii)])\n  const tt = transpileJSX(s, config)\n  const as = SyncReplaceable(tt, [\n    makePasteRule(ef), makePasteRule(defObj), makePasteRule(e),\n    makePasteRule(i), makePasteRule(ias), makePasteRule(ii)])\n  return as\n}\n\nexport default jsx\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_alaJsx.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _alaJsx.Config Options for the program.\n * @prop {(boolean|string)} [quoteProps=false] Whether to surround property names with quotes. When the `dom` string is passed, it will only quote props for invoking html components, i.e., those that start with a lowercase letter (E.g., for the _Google Closure Compiler_). Default `false`.\n * @prop {function(...string)} [warn] The function to receive warnings, e.g., when destructuring of properties is used on dom elements (for Closure Compiler).\n * @prop {boolean} [prop2class=false] If a property name starts with a capital letter, the `className` of the _VNode_ will be updated. Default `false`.\n * @prop {!Array<string>|!Object} [classNames] The list of properties to put into the `className` property.\n * @prop {!Object<string, string>} [renameMap] How to rename classes (only applies to `prop2class` and `classNames`).\n */\n","import erotic from 'erotic'\n\n// /**\n//  * @param {number} length\n//  * @param {number} i\n//  * @param {!Function} fn\n//  */\n// function checkArgumentIndex(length, i, fn) {\n//   if (i > length - 2) {\n//     throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept that many arguments (max ${length - 1} + callback).`)\n//   }\n// }\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn != 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept any arguments.`)\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      // args.forEach((arg, i) => {\n      //   checkArgumentIndex(fnLength, i, fn)\n      // })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      // checkArgumentIndex(fnLength, 0, fn)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","export default _crypto\nexport const {\n  Certificate,\n  Cipher,\n  Credentials,\n  DEFAULT_ENCODING,\n  Decipher,\n  DiffieHellman,\n  ECDH,\n  Hash,\n  Hmac,\n  Verify,\n  createCipher,\n  createCipheriv,\n  createCredentials,\n  createDecipher,\n  createDecipheriv,\n  createDiffieHellman,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  getCurves,\n  getDiffieHellman,\n  getHashes,\n  pbkdf2,\n  pbkdf2Sync,\n  privateDecrypt,\n  privateEncrypt,\n  pseudoRandomBytes,\n  publicDecrypt,\n  publicEncrypt,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  timingSafeEqual,\n} = _crypto","import { createHash } from 'crypto'\n\n// copyright https://medium.com/hackernoon/implementing-a-websocket-server-with-node-js-d9b78ec5ffa8\n\nexport function constructReply(data) {\n  // Convert the data to JSON and copy it into a buffer\n  const json = JSON.stringify(data)\n  const jsonByteLength = Buffer.byteLength(json)\n  // Note: we're not supporting > 65535 byte payloads at this stage\n  const lengthByteCount = jsonByteLength < 126 ? 0 : 2\n  const payloadLength = lengthByteCount === 0 ? jsonByteLength : 126\n  const buffer = Buffer.alloc(2 + lengthByteCount + jsonByteLength)\n  // Write out the first byte, using opcode `1` to indicate that the message\n  // payload contains text data\n  buffer.writeUInt8(0b10000001, 0)\n  buffer.writeUInt8(payloadLength, 1)\n  // Write the length of the JSON payload to the second byte\n  let payloadOffset = 2\n  if (lengthByteCount > 0) {\n    buffer.writeUInt16BE(jsonByteLength, 2)\n    payloadOffset += lengthByteCount\n  } // Write the JSON data to the data buffer\n  buffer.write(json, payloadOffset)\n  return buffer\n}\n\nexport function parseMessage(buffer) {\n  const firstByte = buffer.readUInt8(0)\n  const isFinalFrame = Boolean((firstByte >>> 7) & 0x1)\n  const [reserved1, reserved2, reserved3] = [ Boolean((firstByte >>> 6) & 0x1), Boolean((firstByte >>> 5) & 0x1), Boolean((firstByte >>> 4) & 0x1) ]\n  const opCode = firstByte & 0xF\n  // We can return null to signify that this is a connection termination frame\n  if (opCode === 0x8)\n    return null\n  // We only care about text frames from this point onward\n  if (opCode !== 0x1)\n    return\n  const secondByte = buffer.readUInt8(1)\n  const isMasked = Boolean((secondByte >>> 7) & 0x1)\n  // Keep track of our current position as we advance through the buffer\n  let currentOffset = 2; let payloadLength = secondByte & 0x7F\n  if (payloadLength > 125) {\n    if (payloadLength === 126) {\n      payloadLength = buffer.readUInt16BE(currentOffset)\n      currentOffset += 2\n    } else {\n      // 127\n      // If this has a value, the frame size is ridiculously huge!\n      const leftPart = buffer.readUInt32BE(currentOffset)\n      const rightPart = buffer.readUInt32BE(currentOffset += 4)\n      throw new Error('Large payloads not currently implemented')\n    }\n  }\n  let maskingKey\n  if (isMasked) {\n    maskingKey = buffer.readUInt32BE(currentOffset)\n    currentOffset += 4\n  }\n  // Allocate somewhere to store the final message data\n  const data = Buffer.alloc(payloadLength)\n  // Only unmask the data if the masking bit was set to 1\n  if (isMasked) {\n    // Loop through the source buffer one byte at a time, keeping track of which\n    // byte in the masking key to use in the next XOR calculation\n    for (let i = 0, j = 0; i < payloadLength; ++i, j = i % 4) {\n    // Extract the correct byte mask from the masking key\n      const shift = j == 3 ? 0 : (3 - j) << 3\n      const mask = (shift == 0 ? maskingKey : (maskingKey >>> shift)) & 0xFF\n      // Read a byte from the source buffer\n      const source = buffer.readUInt8(currentOffset++) // XOR the source byte and write the result to the data buffer\n      data.writeUInt8(mask ^ source, i) }\n  } else {\n    // Not masked - we can just read the data as-is\n    buffer.copy(data, 0, currentOffset++)\n  }\n  return `${data}`\n}\n\n/**\n * Creates an accept value for websocket.\n * @param {string} key The client key.\n */\nexport function generateAcceptValue(key) {\n  return createHash('sha1')\n    .update(`${key}258EAFA5-E914-47DA-95CA-C5AB0DC85B11`, 'binary')\n    .digest('base64')\n}","import { b } from 'erte'\nimport { constructReply, parseMessage, generateAcceptValue } from './lib'\n\n/**\n * @type {_idio.websocket}\n */\nfunction websocket(server, config = {}) {\n  const {\n    // eslint-disable-next-line no-unused-vars\n    onMessage = (cid, m) => {},\n    // eslint-disable-next-line no-unused-vars\n    onConnect = (cid) => {},\n    log = true,\n  } = config\n  const clients = {}\n  /**\n   * @param {!http.IncomingMessage} req\n   * @param {!net.Socket} socket\n   */\n  function listener(req, socket) {\n    /**\n     * @suppress {checkTypes}\n     */\n    const UPGRADE = req.headers['upgrade']\n    if (UPGRADE != 'websocket') {\n      socket.end('HTTP/1.1 400 Bad Request')\n      return\n    }\n    /**\n     * @suppress {checkTypes}\n     */\n    const PROTO = req.headers['sec-websocket-protocol']\n    /**\n     * @suppress {checkTypes}\n     */\n    const KEY = req.headers['sec-websocket-key']\n    const hash = generateAcceptValue(KEY)\n    const responseHeaders = [\n      'HTTP/1.1 101 Web Socket Protocol Handshake',\n      'Upgrade: WebSocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${hash}`,\n    ]\n    // Read the subprotocol from the client request headers:\n    const protocols = !PROTO ? [] : PROTO.split(',').map(s => s.trim())\n    if (protocols.includes('json')) {\n      responseHeaders.push('Sec-WebSocket-Protocol: json')\n    }\n    socket.write(responseHeaders.join('\\r\\n') + '\\r\\n\\r\\n')\n    log && console.log(b('Client connected.', 'green'))\n    socket.on('data', buffer => {\n      const message = parseMessage(buffer)\n      if (message) {\n        onMessage(KEY, message)\n      } else if (message === null) {\n        delete clients[KEY]\n        log && console.log(b('Client disconnected.', 'red'))\n      }\n    })\n    /**\n     * @type {_idio.sendMessage}\n     */\n    const sendMessage = (event, message) => {\n      socket.write(constructReply({ event, message }))\n    }\n    clients[KEY] = sendMessage\n    onConnect(KEY)\n  }\n  server.on('upgrade', listener)\n  return clients\n}\n\nexport default websocket\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').websocket} _idio.websocket\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').sendMessage} _idio.sendMessage\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('http').IncomingMessage} http.IncomingMessage\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('net').Socket} net.Socket\n */","import { join, relative, resolve, dirname, parse } from 'path'\r\nimport exists from '@wrote/exists'\r\nimport read from '@wrote/read'\r\nimport resolveDep from 'resolve-dependency'\r\n\r\nlet ROOT\r\n\r\n/**\r\n * Finds the location of the `package.json` for the given dependency in the directory, and its entry file.\r\n * @param {string} dir The path to the directory where the requiring file is located.\r\n * @param {string} name The name of the required package.\r\n * @param {!_fpj.Config} opts The options for `fpj`.\r\n * @param {!Array<string>} [opts.fields] Any additional fields from `package.json` file to return.\r\n * @param {boolean} [opts.soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\r\n * @returns {!Promise<!_fpj.Return>}\r\n */\r\nconst findPackageJson = async (dir, name, opts = {}) => {\r\n  if (!ROOT) {\r\n    ({ root: ROOT } = parse(process.cwd()))\r\n  }\r\n  const { fields, soft = false } = opts\r\n  const fold = join(dir, 'node_modules', name)\r\n  const path = join(fold, 'package.json')\r\n  const e = await exists(path)\r\n  if (e) {\r\n    const res = await findEntry(path, fields)\r\n    if (res === undefined)\r\n      throw new Error(`The package ${relative('', path)} does export the module.`)\r\n    else if (!res.entryExists && !soft)\r\n      throw new Error(`The exported module ${res.main} in package ${name} does not exist.`)\r\n    const { entry, version, packageName, main, entryExists, ...rest } = res\r\n    const result = /** @type {!_fpj.Return} */ ({\r\n      entry: relative('', entry),\r\n      packageJson: relative('', path),\r\n      ...(version ? { version } : {}),\r\n      packageName,\r\n      ...(main ? { hasMain: true } : {}),\r\n      ...(!entryExists ? { entryExists: false } : {}),\r\n      ...rest,\r\n    })\r\n    return result\r\n  }\r\n  if (dir == ROOT && !e)\r\n    throw new Error(`Package.json for module ${name} not found.`)\r\n  return findPackageJson(join(resolve(dir), '..'), name, opts)\r\n}\r\n\r\n/**\r\n * Finds the path to the entry based on package.json file.\r\n * @param {string} path\r\n * @param {!Array<string>} fields\r\n */\r\nexport const findEntry = async (path, fields = []) => {\r\n  const f = await read(path)\r\n  let mod, version, packageName, main, rest\r\n  try {\r\n    ({\r\n      'module': mod,\r\n      'version': version,\r\n      'name': packageName,\r\n      'main': main,\r\n      ...rest\r\n    } = JSON.parse(f))\r\n    rest = fields.reduce((acc, current) => {\r\n      acc[current] = rest[current]\r\n      return acc\r\n    }, {})\r\n  } catch (err) {\r\n    throw new Error(`Could not parse ${path}.`)\r\n  }\r\n  const dir = dirname(path)\r\n  let resolved = mod || main\r\n  if (!resolved) {\r\n    const indexExists = await exists(join(dir, 'index.js'))\r\n    if (!indexExists) return undefined\r\n    resolved = main = 'index.js'\r\n  }\r\n  let entry = join(dir, resolved)\r\n  let r\r\n  try {\r\n    ({ path: r } = await resolveDep(entry))\r\n    entry = r\r\n  } catch (err) {/* does not exist */}\r\n  return { entry, version, packageName, main: !mod && main,\r\n    entryExists: !!r,\r\n    ...rest }\r\n}\r\n\r\nexport default findPackageJson\r\n\r\n/* documentary types/index.xml */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_fpj.Config} Config The options for `fpj`.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _fpj.Config The options for `fpj`.\r\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` file to return.\r\n * @prop {boolean} [soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_fpj.Return} Return The return type of the program.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _fpj.Return The return type of the program.\r\n * @prop {string} entry The location of the package's entry file. The preference is given to the `module` field.\r\n * @prop {string} packageJson The path to the package.json file itself.\r\n * @prop {string} packageName The name of the resolved package.\r\n * @prop {string} [version] The version of the package.\r\n * @prop {boolean} [hasMain] Whether the entry is the `main` rather than `module`.\r\n * @prop {boolean} [entryExists] In soft mode, will be set to `false` if the entry file does not exist.\r\n */\r\n","import { collect } from 'catchment'\nimport { Replaceable } from 'restream'\nimport { relative, join, dirname, resolve } from 'path'\nimport findPackageJson from 'fpj'\nimport split from '@depack/split'\n\n/**\n * Updates the source code of served JS files to point to the `/node_modules`, e.g., `import 'preact'` -> `import '/node_modules/preact/dist/preact.mjs'`.\n * @param {string} path\n * @param {string} source\n */\nexport const patchSource = async (path, source, { mount, override = {} }) => {\n  const replacement = async (m, pre, from) => {\n    const dir = dirname(path)\n    // ignore local deps which are resolved by middleware\n    if (/^[/.]/.test(from)) {\n      return m\n    }\n    const { name, paths } = split(from)\n    if (override[name]) return `${pre}'${override[name]}'`\n    const {\n      packageJson,\n    } = await findPackageJson(dir, name)\n    const abs = resolve(packageJson)\n    const realFrom = dirname(abs)\n    // explicit dep, e.g., @depack/example/src/index.jsx\n    if (paths) {\n      return getNodeModule(realFrom, paths, pre, mount)\n    }\n    // try module\n    const { module: mod } = require(abs)\n    if (!mod) {\n      console.warn('[\u219b] Package %s does not specify module in package.json, trying src', realFrom)\n      const d = getNodeModule(realFrom, 'src', pre)\n      return d\n    }\n    return getNodeModule(realFrom, mod, pre, mount)\n  }\n  const rs = new Replaceable([\n    {\n      re: /^( *import(?:\\s+[^\\s,]+\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+)['\"](.+)['\"]/gm,\n      replacement,\n    },\n    {\n      re: /^( *import\\s+)['\"](.+)['\"]/gm,\n      replacement,\n    },\n  ])\n  rs.end(source)\n  const body = await collect(rs)\n  return body\n}\n\n\n/**\n * Returns the import statement with the path to the dependency on the file system.\n * @param {string} from File from which module was imported.\n * @param {string} path The import path.\n * @param {string} pre Text before import.\n * @param {string} [mount]\n */\nconst getNodeModule = (from, path, pre, mount) => {\n  const modPath = join(from, path)\n  let modRel = relative('', modPath)\n  if (mount) modRel = relative(mount, modRel)\n  return `${pre}'/${modRel}${modPath.endsWith('/') ? '/' : ''}'`\n    .replace(/\\\\/g, '/')\n}","/**\n * Splits the package name possibly with scope and returns the name and the\n * path within that page that was required.\n * @param {string} from The package, e.g., `@depack/depack/src`, or `depack`.\n */\nconst split = (from) => {\n  let [scope, name, ...paths] = from.split('/')\n  if (!scope.startsWith('@') && name) {\n    paths = [name, ...paths]\n    name = scope\n  } else if (!scope.startsWith('@')) {\n    name = scope\n  } else {\n    name = `${scope}/${name}`\n  }\n  return { name, paths: paths.join('/') }\n}\n\nexport default split","/* eslint-env browser */\n\nexport default function(css = '') {\n  const head = document.head\n  const style = document.createElement('style')\n  style.type = 'text/css'\n  if (style.styleSheet){\n    style.styleSheet.cssText = css\n  } else {\n    style.appendChild(document.createTextNode(css))\n  }\n  head.appendChild(style)\n}","import { basename } from 'path'\nimport mismatch from 'mismatch'\nimport { EOL } from 'os'\n\n/**\n * Returns exported clasess.\n * @param {string} content The contents of a file\n */\nexport const getClasses = (content) => {\n  const d = mismatch(/export\\s+(default\\s+)?class\\s+([^\\s{]+)/g, content, ['def', 'name'])\n  const dd = d.reduce((acc, { 'def': def, 'name': name }) => {\n    acc[def ? 'default' : name] = name\n    return acc\n  }, {})\n  return dd\n}\n\n/**\n * Returns the code to append to modules to reload classes.\n * @param {string} path Path to the module.\n * @param {!Object} classes The object with classes\n */\nexport const HR = (path, classes) => {\n  const s = Object.entries(classes).map(([k, v]) => {\n    return `'${k}': ${v},`\n  })\n  return `/* IDIO HOT RELOAD */\nif (window.idioHotReload) {\n  let i = 0\n  idioHotReload('${path}', async () => {\n    i++\n    const module = await import(\\`./${basename(path).replace(/\\.jsx?$/, '')}?ihr=\\${i}\\`)\n    return {\n      module,\n      classes: {\n${s.map(t => `        ${t}`).join(EOL)}\n      },\n    }\n  })\n}`.replace(/\\r?\\n/g, EOL)\n}\n","/* eslint-disable quote-props */\nimport read from '@wrote/read'\nimport transpileJSX from '@a-la/jsx'\nimport resolveDependency from 'resolve-dependency'\nimport makePromise from 'makepromise'\nimport { lstat, existsSync, readFileSync } from 'fs'\nimport { join, relative } from 'path'\nimport mismatch from 'mismatch'\nimport websocket from '@idio/websocket'\nimport { EOL } from 'os'\nimport { patchSource } from './lib'\nimport __$styleInject from './inject-css'\nimport { HR, getClasses } from './lib/hr'\n\nconst watch = require(/* dpck */ 'node-watch')\n\nconst listener = readFileSync(join(__dirname, 'listener.js'))\n\n/**\n * @type {!_idio.frontEnd}\n */\nfunction FrontEnd(config = {}) {\n  const {\n    directory = 'frontend',\n    pragma = 'import { h } from \\'preact\\'',\n    mount = '.',\n    override = {},\n    jsxOptions,\n    exportClasses = true,\n    hotReload,\n  } = config\n  let { log } = config\n  if (log === true) log = console.log\n  let dirs = Array.isArray(directory) ? directory : [directory]\n\n  // check if all dirs exist\n  dirs = dirs.map((current) => {\n    const dir = join(mount, current)\n    const e = existsSync(dir)\n    if (!e)\n      throw new Error(`Frontend directory ${current} does not exist.`)\n    return current.replace(/\\\\/g, '/')\n  })\n\n  let CLIENTS = {}, WATCHING\n  if (hotReload) {\n    ({ watchers: WATCHING = {} } = hotReload)\n  }\n\n  let upgraded = false\n  /**\n   * @type {!_goa.Middleware}\n   */\n  const m = async (ctx, next) => {\n    if (hotReload && ctx.path == (hotReload.path || '/hot-reload.js')) {\n      ctx.type = 'js'\n      ctx.body = listener\n      if (!upgraded) {\n        const server = hotReload.getServer()\n        CLIENTS = websocket(server)\n        upgraded = true\n      }\n      return\n    }\n    let p = ctx.path.replace('/', '')\n    const canServe = dirs.includes(p)\n      || dirs.some(d => p.startsWith(`${d}/`))\n      || ctx.path.startsWith('/node_modules/')\n    if (!canServe) {\n      return next()\n    }\n    p = join(mount, p).replace(/\\\\/g, '/')\n    const { path, isDir } = await resolveDependency(p)\n    if (isDir && !p.endsWith('/')) {\n      const mountPath = mount ? relative(mount, path).replace(/\\\\/g, '/') : path\n      ctx.redirect(`/${mountPath}`)\n      return\n    }\n    /** @type {!fs.Stats} */\n    let ls\n    try {\n      ls = /** @type {!fs.Stats} */ (await makePromise(lstat, path))\n    } catch (err) {\n      ctx.status = 404\n      return\n    }\n    ctx.status = 200\n    ctx.etag = `${ls.mtime.getTime()}`\n    if (ctx.fresh) {\n      ctx.status = 304\n      return await next()\n    }\n    let body = await read(path)\n    let start = new Date().getTime()\n    body = await patch(path, body, pragma, {\n      mount, override, jsxOptions, exportClasses,\n    })\n    let end = new Date().getTime()\n    if (log) /** @type {!Function} */ (log)('%s patched in %sms', path, end - start)\n    ctx.type = 'application/javascript'\n\n    if (hotReload && !ctx.query.ihr) {\n      if (path.startsWith('node_modules') && hotReload.ignoreNodeModules) {\n        // continue\n      } else {\n        if (!(path in WATCHING)) {\n          const watcher = watch(path, (type, filename) => {\n            console.log('File %s changed', filename)\n            Object.values(CLIENTS).forEach((v) => {\n              v('update', { filename })\n            })\n          })\n          WATCHING[path] = watcher\n        }\n        if (path.endsWith('jsx')) {\n          const classes = getClasses(body)\n          const hr = HR(path, classes)\n          body += `${EOL}${EOL}${hr}`\n        }\n      }\n    }\n\n    ctx.body = body\n  }\n  return m\n}\n\nexport default FrontEnd\n\n/**\n * Patches the source code to map node_modules and transpile JSX.\n * @param {string} path Path to the file.\n * @param {string} body The source code to patch.\n * @param {string} pragma Add this import to the body.\n */\nconst patch = async (path, body, pragma, config) => {\n  const { jsxOptions, exportClasses } = config\n  if (/\\.jsx$/.test(path)) {\n    body = transpileJSX(body, jsxOptions)\n    if (pragma) body = `${pragma}${EOL}${body}`\n  }\n  if (/\\.css$/.test(path)) {\n    body = wrapCss(body, exportClasses)\n  } else {\n    body = await patchSource(path, body, config)\n  }\n  return body\n}\n\n/**\n * Adds JS wrapper to add CSS dynamically.\n * @param {string} style\n */\nconst wrapCss = (style, exportClasses = true) => {\n  let classes = []\n  if (exportClasses) {\n    const c = style.split(/\\r?\\n/)\n      .filter((a) => {\n        return /^\\S/.test(a)\n      }).join(EOL)\n    classes = mismatch(/\\.([\\w\\d_-]+)/g, c, ['className'])\n      .map(({ 'className': cl }) => cl)\n      .filter((v, i, a) => a.indexOf(v) == i)\n  }\n  return `(${__$styleInject.toString()})(\\`${style}\\`)\n${classes.map((cl) => {\n    return `export const $${cl} = '${cl}'`\n  }).join(EOL)}`.replace(/\\r?\\n/g, EOL).trim()\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').frontEnd} _idio.frontEnd\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('@typedefs/goa').Middleware} _goa.Middleware\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import '@externs/goa'\nimport '../types/externs'\nimport FrontEnd from './'\n\nmodule.exports = FrontEnd"],
"names":["createReadStream","fs","existsSync","lstat","readFileSync","$jscompDefaultExport","stream","Transform","Writable","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","EOL","os","homedir","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","read","path","Script","vm","findPosition","input","h","l2","l","parseInt","c","detectJSX","err","bl","checkRule","reObject","hasRe","type","replacement","hideStack","commonError","thrownError","commonLine","i","substr","li","lastIndexOf","SyncReplaceable","rules","fr","reduce","s","acc","_broke","Acc","t","call","p","brake","replace.brake","getDefaultRegExp","name","toUpperCase","getDefaultReplacement","index","makeMarkers","matchers","config","keys","key","getReplacement","getRegex","regExp","lastIndex","marker","makePasteRule","pipeRules","rule","Array","isArray","pr","makeCutRule","replaceable","Replaceable","_options","context","Replaceable$$module$node_modules$restream$src$Replaceable.replace","forEach","string","promises","resolve","data","all","shift","next","Stream","end","getTagName","tagName","exec","getProps","props","withClass","classNames","renameMap","positions","current","closing","opening","open","close","obj","destructuring","whitespace","lastClose","before","wsBefore","propName","wsBeforeAssign","afterAssign","val","beforeAssign","beforeOrNot","bb","plain","ws","getPlain","whatsLeft","ro","cl","k","className","cn","class","wsAfterAssign","q","repeat","Boolean","makeObjectBody","pp","quoteProps","beforeCloseWs","a","v","kk","isComponentName","pragma","children","warn","tn","qp","cc","prev","comma","findEnding","contentEnd","preString","extract","stringWithTag","arrow","content","selfClosing","ExtractedJSX","contentStart","stringEnd","opensClosing","endsWith","untilEnd","ce","tSelfClosing","string2","getQuoted","_b","_a","b","rr","parseSimpleContent","temps","expressionStack","jsxStack","isExpression","to","expression","extractedJsx","getTemps","lastTo","ar","transpileJSX","prop2class","position","parseContent","f","after","ld","newRes","contents","jsx","part","strBefore","strAfter","defObj","ef","ias","ii","tt","as","makePromise","fn","resolveValue","fnLength","reject","error","allArgs","exists","ls","basename","dirname","parse","relative","resolveDependency","isDir","checkSources","isDirectory","fileChecked","fileRes","startsWith","mismatch","o","capturedGroup","start","backgroundColors","color","createHash","_crypto","constructReply","json","JSON","stringify","jsonByteLength","byteLength","lengthByteCount","payloadLength","buffer","alloc","writeUInt8","payloadOffset","writeUInt16BE","write","generateAcceptValue","update","digest","websocket","server","onMessage","onConnect","log","clients","listener","req","socket","headers","UPGRADE","PROTO","KEY","responseHeaders","hash","protocols","console","opCode","readUInt8","firstByte","secondByte","isMasked","currentOffset","readUInt16BE","readUInt32BE","maskingKey","mask","copy","event","sendMessage","ROOT","findPackageJson","dir","process","cwd","fields","soft","fold","findEntry","entryExists","main","entry","version","packageName","rest","result","packageJson","hasMain","mod","resolved","indexExists","patchSource","mount","override","pre","scope","paths","abs","realFrom","getNodeModule","require","body","modPath","modRel","css","head","document","style","createElement","styleSheet","cssText","appendChild","createTextNode","getClasses","dd","def","HR","classes","entries","watch","__dirname","patch","jsxOptions","exportClasses","wrapCss","__$styleInject","toString","module","exports","FrontEnd","directory","hotReload","dirs","CLIENTS","WATCHING","upgraded","ctx","getServer","some","mountPath","redirect","status","etag","mtime","getTime","fresh","Date","query","ihr","ignoreNodeModules","watcher","filename","values","hr"]
}
